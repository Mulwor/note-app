/* Паттерн builder (строитель) используется для создания объектов со сложными состояниями, также
он может иметь дополнительный слой абстракции (директор, который управляет несколько строителями) */

/* Напомним, что создания объекта с определенными значениями инициализируется в констукторе. В нем
могут задаваться различные свойства будущего объекта, однако если данный процесс усложняется и свой-
ства начинают зависить от различных факторов и добавляться они могут также в зависимости от различных
условий, то конструктор класса может разростись до невероятных размеров, чтобы такого не произошло как
раз так и используется паттерн Builder, который позволяет создавать сложные объекты инициализация, ко-
торого проблематично уместить в констркуторе */

class Car {
    // Конструктор, в котором мы определяем будущие свойства
	constructor() {
		this.autoPilot = false;
		this.parktronic = false;
		this.signaling = false; 
        // По умолчанию данные опции не входят в состав производимого автомобиля
	}
}

// Для целей модификации нам необходимо создать класс carBuilder
class CarBuilder {
	constructor() {
        /* Инициализируем создания экземпляра класса нашего автомобиля (то есть внутри бил-
        дера создаем наш автомобиль базовой комплектации, теперь наше авто доступно по ссыл-
        ке this.car) */
		this.car = new Car();
	}
    /* У нас есть 3 метода на обновление наших опций - addAutoPilot, addParktronic, addSignaling
	То есть добавления каждой из опций, стоит обратить внимание, что каждый из методов может
    применять аргумент снаружи. Мы самостоятельно указываем и переопределяем в случае необходимости
    какое-то из свойств. */
    addAutoPilot(autoPilot) {
		this.car.autoPilot = autoPilot;
        /*В каждом из методов мы возвращаем this - это нужно для того, чтобы каждое из 
        свойств могло работать с контекстом и мы могли вызывать методы по цепочке */
		return this;
	}
	addParktronic(parktronic) {
		this.car.parktronic = parktronic;
		return this;
	}
	addSignaling(signaling) {
		this.car.signaling = signaling;
		return this;
	}
    /* В дополнение у нас есть метод update engine, вы можете заказать лучший двигатель чем
    тот, что устанавливается в машину по умолчанию. Причем обратите внимание, что в начальном объекте
    данного параметра нет, это не значит, что в машине нет двигателя - он просто будет стандартный
    В этом методе мы можем заказать улучшенный вариант
    */
	updateEngine(engine) {
		this.car.engine = engine;
		return this;
	}
    // Данный метод возвращает объект нашего компликтованого автомобиля (собираем новое авто)
	build() {
		return this.car;
	}
}

/*Если мы вызовем без параметров, мы получим стандартную модель, однако если мы используем метод
билдера. Итоговый объект автомобиля у нас изменился */
const myCar = new CarBuilder()
                    .addAutoPilot(true)
                    .addParktronic(true)
                    .updateEngine('V8')
                    .build()
/* Стоит обратить внимание, что каждый из методов идет сразу за следующим по цепочке. В этом и есть
одна из особенностей buildera. То есть полное конфигурирование нужного объекта максимально простым ин-
терфейсом*/


console.log(myCar);
/* Car {
  autoPilot: true, 
  parktronic: true,
  signaling: false,
  engine: 'V8'     
} */

/* Данный патерн в очень удобной форме позволяет создавать различные конфигурации объектов не засо-
ряя исходный конструктор доп.логикой, которая в нем не нужна */