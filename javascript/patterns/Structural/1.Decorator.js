/* Паттерн Декоратор - с помощью него мы можем добавлять объектом новые свойства и методы, то есть оборачивать
наш объект в этот самый класс декоратора и тем самым расширять его возможности.*/ 

/*Он используется тогда когда если нам необходимо создать большое кол-во подклассов. 
Например: у нас есть какая-то загатовка на основании которой мы можем собрать и BMV и Тесла, 
таким образом на основании нашего конструктора появляются огромное кол-во дочерних классов или
разновидновстей авто и такую проблему (уменьшение классов) нам поможет решить декоратор */

/*Декоратором может выступать класс, который принимает объект и добавляет к нему доп.свойства или методы, тем 
самым расширяет его (другими словами он может добавить автопилот и к БМВ и к Аудио и т. д.) и стоимость этой 
операции стоимость авто изменится */

// Эталонная конструкция авто (14-28)
class Car {
    // обычный объект со свойством цена и модель
	constructor() {
		this.price = 10000;
		this.model = 'Car'
	}

    // возможно получать эти данные с помощью getprice и getDesctription
	getPrice() {
		return this.price;
	}
	getDescription() {
		return this.model
	}
}

// На основании этого абстрактного класса, создаем класс определенного автомобиля
class Tesla extends Car {
    // В данном классе мы уже более конкретно определяем стоимость нашей базовой модели и её название (Тесла в базовой комплектации)
	constructor() {
		super();
		this.price = 25000;
		this.model = 'Tesla';
	}
}

// Базовая комплектация нас не устраивает, и нам нужен автопилот и парктроник
/* Создаем соответствующие декораторы: class Autopilot и class Parktronic, оба декоратора принимают 
автомобиль добавляет в него новую опцию и в соответствии изменяет итоговую стоимость и описание.*/
class Autopilot {
	constructor(car) {
		this.car = car;
  	}

	getPrice() {
		return this.car.getPrice() + 5000;
	}
  
	getDescription() {
		return `${this.car.getDescription()} with autopilot`;
	}
}

class Parktronic {
	constructor(car) {
		this.car = car;
	}

	getPrice() {
		return this.car.getPrice() + 3000;
	}
  
	getDescription() {
		return `${this.car.getDescription()} with parktronic`;
	}
}

/* Теперь у нас есть все необходимые данные и мы можем создать автомобиль, который нас полностью 
конструктивно устраивает */
let tesla = new Tesla();
tesla = new Autopilot(tesla);
tesla = new Parktronic(tesla);
/* Описание авто с добавленными отступами и его итоговая стоимость, мы получили именно ту модификацию, кото-
рую хотели */
console.log(tesla.getPrice(), tesla.getDescription());      // 33000 Tesla with autopilot with parktronic

/*Если нас не устраивает одна из опций мы можем спокойно удалить либо мы можем создать новый автомобиль
и добавить в него опций */
let tesla2 = new Tesla ();
tesla2 = new Autopilot(tesla2);
console.log (tesla2.getPrice(), tesla2.getDescription());   // 30000 Tesla with autopilot

// Суть данного паттерна - обернуть существующий класс и расширить его функциональность 