### Задачи с собеседований - 1

### Объект

---

✅ Есть объект, какие ты способы знаешь, чтобы его скопировать (заклонить)

```js
const person = { name: "Valera", surname: "Valerovich" }
```

<details>
<summary>Ответ</summary>

- Через спред оператор {...person};
- Через метод объекта: Object.assign();
- Через JSON.parse(JSON.stringify());

</details>

---

✅ Что будет в консоль логе? 

```js
let firstObj = { greeting: 'hey' };
let secondObj = firstObj;

firstObj.greeting = 'ho';

console.log(secondObj.greeting); // ?
firstObj = { greeting: 'hello' };
console.log(secondObj.greeting); // ?
```

<details>
<summary>Ответ</summary>

`let secondObj = firstObj` - создается ссылка на тот же объект. Потом меняем свойство объекта, на который ссылаются обе переменные

`firstObj = { greeting: 'hello' }` - создается новый объект, 

Ответ буде ho и ho так как secondObj ссылается на 27 строку firstObject
</details>

---

✅ Что будет в консоль логе? 

```js
let a = {};
let b = {};

b[a] = 1

console.log(b);
```

<details>
<summary>Ответ</summary>

`{ "[object Object]": 1 }`

b[a] = 1 - пытаемся использовать объект `a` как ключ объекта `b`
Объект a автоматически преобразуется в строку через toString()
a.toString() возвращает "[object Object]"
Фактически выполняется: b["[object Object]"] = 1
</details>

---

✅ Что будет в консоль логе? 

```js
let a = {};
let b = {};
let obj = { [a]: 1, [b]: 2 };

console.log(obj[a] + obj[b])       // 4
```

<details>
<summary>Ответ</summary>

1. У объектов ключи могут быть либо строками либо символами. 
2. Когда мы используем объект в качестве ключа в квадратных скобках `a` и `b`, то он автоматически преобразует в строку. В объекте получается следующее

```js
let obj = { 
  "[object Object]": 1, 
  "[object Object]": 2 
};
```

А так как ключи у нас одинаковы, то они перезаписываются и сохраняется лишь последнее значение 2. Ответ будет 4. 
</details>

✅ Что будет в консоль логах? 

```js
(function() {
  var a = b = 3
})();

console.log(typeof a)       
console.log(typeof b)       
```

<details>
<summary> Ответ </summary>
undefined и number

Переменная объявленная через var видны в рамках функции, у нас в данной записи переменная b становится глобальной, то есть считается что она объявлена без какого-либо ключевого слова

</details>

✅ Что будет в консоль логах? Рассмотри вариант с переменной объявленной через let

```js
var b = 50;

function k() {
  console.log(b);
  if (true) {
    // 1. let b = 150
    var b = 150;
    console.log(b);
  };
  console.log(b)
}

k();             
```

<details>
<summary>Ответ</summary>

// 50, 150, 150

Если внутри функции - `function k() {...}` у нас есть переменная объявленная var, то мы будем обращаться именно к ней. Если мы обращаемся к переменной до его инициализации то она будет равно undefined
</details>

А если так?

```js
var b = 50;

function k() {
  console.log(b);
  if (b) {
    var b = 150;
    console.log(b);
  };
  console.log(b)
}

k();   
```

<details>
<summary> Ответ </summary>
// undefined, undefined

b - не инициализирован и он не попадает внутрь
</details>

---

✅ Что будет в консоль логе? 

```js
const a = { a: "a" };
const b = { b: "b" };
const c = {};

c[a] = a;
c[b] = b;

console.log(c[a].a, c[b].b); 
```

<details>
<summary>Ответ</summary>

В JavaScript ключи объекта могут быть только строками или символами.
Когда объект используется как ключ, он автоматически преобразуется в строку через toString() => `a.toString() возвращает "[object Object]"`,

```js
a.toString => [object, Object]: a;
b.toString => [object, Object]: b;

{
  [object, Object]: a, // убирается так как перезаписывается следующее значение
  [object, Object]: b,
}

При попытке вызвать c[a].a вернет undefined, так как он не находит его
```

</details>

---

✅ Будет ли переменная b одинаковой переменной a, то есть будут ли они визуально одинаковые или разные. Какой будет ответ и как правильно отсортировать

```js
const a = [10, 8, 2, 1, 5, 7, 4, 9]
const b = a.sort()
```

<details>
<summary>Ответ</summary>

Да, ответ будет одинаковый, так как метод sort мутирует (меняет исходный) исходный массив: [1, 10, 2, 4, 5, 7, 8, 9]. А чтобы правильно отсортировать необходимо a.sort((a, b) => (a - b))    
</details>

---

✅ Необходимо отсортировать массив по order, и нужно деструктуризовать его

```js
const input = [
  { order: 4, value: 'abcd' },
  { order: 2, value: 'qwer' },
  { order: 1, value: 'xyz1' },
  { order: 3, value: 'abx2' },
];
```

<details>
<summary>Ответ</summary>

1. Если нам нужна простая сортировка: `input.sort((a, b) => a.order - b.order);`
2. Если нам нужна деструктуризация: `input.sort(({ order: orderA }, { order: orderB }) => orderA - orderB);`
..
</details>

---

✅ У нас есть массив чисел, необходимо посчитать их однако число должно начинаться не с 0, а с -1

```
const digits = [1, 2, 3, 4]
```

<details>
<summary>Ответ</summary>

- Через reduce digits.reduce((a, b) => a + b, -1)
- Через цикл

```js
function sum (digits) {
  let value = -1;
  for (let i = 0; i < digits.length; i++) {
    value += digits[i]
  }
  return value
}
sum([1, 2, 3, 4])
```
</details>
</details>


✅ Какой будет ответ

```js
const userService = {
  currentFilter: 'active',
  users: [
    { name: "Alex", status: "active" },
    { name: "Nick", status: "deleted" },
  ],
  getFilteredUsers: function() {
    return this.users.filter(function (user) {
      return user.status === this.currentFilter
    });
  }
}

console.log(userService.getFilteredUsers())
```

<details>
<summary>Ответ</summary>
Вернет пустой массив, так как внутри функции фильтр мы здесь объявили через function declaration и как раз внутри this потеряется. 
</details>

✅ Какой будет ответ

```js
const array = [1, 2, 3];
const array2 = array.map(item => item * 2).filter(item => item > 3);
const array3 = array.filter(item => item * 2 > 3);
console.log(array2, array3)     // [4, 6], [2, 3]
```

<details>
<summary>Ответ</summary>

Array2 в начале все числа умножает на 2, а потом фильтрует их, если больше 3, то он оставляет эти числа. То есть ответ 4 и 6, 

В то время как в array3 происходит только фильтрация то есть условно 1 * 2 > 3 = 2 > 3 не попадает, 2 * 2 > 3 - попадает значит 2 оставляем а затем 3 оставляем
</details>

✅ Что выведется?

```js
'use strict'
var obj = {
  i: 10,
  b: () => console.log(this.i, this),
  c: function() {
    console.log(this.i, this)
  }
}

obj.b()
obj.c()
```

✅ Что выведется?

```js
var test = (function() {
  var value = 1;
  function setValue(newValue) {
    value = newValue
    console.log(value, 'and', newValue)
  }
  return {
    value: value,
    setValue: setValue
  }
})();
test.setValue(2);
console.log(test.value)
```

---

✅ Напишите функцию, которая переворачивает строку 

```js
const str = "Welcome to this JavaScript Guide!"; // => "emocleW ot siht ...."
const reverseWords = (str) => { ... };
console.log(reverseWords(str));
```

<details>
<summary>Ответ</summary>
 
```js
const str = "Welcёome to this JavaScript Guide!";

const reverseWords = (str) => {
  // return str.split("").reverse().join("").split(" ").reverse().join(' ')
  return str.split(" ").map(word => word.split("").reverse().join("")).join(" ");
};

console.log(reverseWords(str));
```

</details>

---

✅ Напишите функцию, которая удаляет дубликаты внутри массива

<details>
<summary>Ответ</summary>

1. Через такую структуру данных как [...new Set(array)]
2. Через filter и indexOf(element)

```js
const makeUniq = (names) => {
  return names.filter((element, id) => arr.indexOf(element) === id);
}
```

3. Через цикл

```js
const arr = [1, 1, 2, 3, 4, 4, 5, 5];

const removeDuplicates = (arr) => {
  let result = [];

  for (let i = 0; i < arr.length; i++) {
    if (arr[i] !== arr[i + 1]) {
      result.push(arr[i])
    }
  }

  return result;
};

removeDuplicates(arr)
```

</details>

---

✅ Написать функцию, которая принимает массив чисел и возвращает массив, содержащий только те числа, которые встречаются в исходном массиве только один раз. Например, для массива [1, 1, 2, 3, 3, 4, 5, 6, 7, 7, 5, 6] результат должен быть [2, 4].

```js
export const TEST_ARRAY = [1, 1, 2, 3, 3, 4, 5, 6, 7, 7, 5, 6];
export const notRepeat = (testArr) => {};
notRepeat(TEST_ARRAY);
```

<details>
<summary>Ответ</summary>

1. Решение через цикл

```js
function onlyOneInArray(array) {
  let result = [];
    
  for(let i = 0; i < array.length; i++) {
    let count = 0;
        
    for(let j = 0; j < array.length; j++) {
      if (array[i] === array[j]) count++;
    }
  
    if (count === 1) result.push(array[i]);
  }
    
  return result;
}
```

2. Решение через фильтр и индекс офф

```js
const notRepeat = (testArr) => {
  return testArr.filter((num, index, arr) => 
    arr.indexOf(num) === arr.lastIndexOf(num)
  );
};
```
</details>

---

✅ Что выведется в консоль

```js
const year = Date.getYear();   
const month = Date.getMonth(); 
const day = Date.getDay();  

console.log(year, month, day)
```

<details>
<summary>Ответ</summary>

Месяц начинается с нуля
</details>

---
✅ В чем разница между process1 / process2. Представим себе, что каждый из action выполняется по 10 секунд, какой из action выполнится раньше и почему.

```js
type action = () => Promise<string>

async function process1(action1: action, action2: action, action3: action): Promise<string[]> {
  const res1 = await action1();
  const res2 = await action2();
  const res3 = await action3();

  return [res1, res2, res3]
}

async function process2(action1: action, action2: action, action3: action): Promise<string[]> {
  return Promise.all([action1(), action2(), action3()])
}
```

<details>
<summary>Ответ</summary>

Выполните process2 так как метод promise.All - запускает promise параллельно и если у каждого из них будет по 10 секунд, то и выполнится он за 10 сек, так
как они параллельный в то время как в process1 - этого нет в начале выполнится первый await, а потом через 10 секунд второй, а потом через еще 10 третий

</details>

---

✅ Разработчик отправил на ревью, но убрал resolve. Вопрос: когда начнется action2 и начнется ли он?

```js
const action2 = () => new Promise((res, rej) => {
  // res("SUCCESS")
});

async function process3(action1: action, action2: action, action3: action): Promise<string[]> {
  const res1 = await action1();
  const res2 = await action2();
  const res3 = await action3();

  return [res1, res2, res3]
}
```

<details>
<summary>Ответ</summary>

Promise никогда не завершится ни успехом, ни ошибкой, и будет находиться в состоянии pending бесконечно.

</details>

---
✅ Попросили подправить код и он подправил, однако вместо resolve у него теперь reject и async убрал Process1 - завершится или нет, и что будет результатом

```js
const action2 = () => return new Promise((res, rej) => {
  rej("SUCCESS")
});

async function process1(action1: action, action2: action, action3: action): Promise<string[]> {
  const res1 = await action1();
  const res2 = action2();
  const res3 = await action3();

  return [res1, res2, res3]
}
```

<details>
<summary>Ответ</summary>

Нет, функция завершится с ошибкой. На этапе возврата массива [res1, res2, res3] произойдёт ошибка из-за отклонённого промиса res2.

</details>

---

✅ Необходимо написать функцию для слипа (sleep), чтобы он выполнился через 300 миллисекнуж после process1 и протипизируйте его

```js
const action2 = () => return new Promise((res, rej) => {
   res("SUCCESS")
})

async function process1(action1: action, action2: action, action3: action): Promise<string[]> {
  const res1 = await action1();
  const res2 = await action2();
  const res3 = await action3();

  return [res1, res2, res3]
}

function sleep(time) {
  ...
}

const superProcess = async () => {
  await process1{...}
  await sleep(300)
  await process2{...}
}

```

<details>
<summary>Ответ</summary>

```js
function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
```

</details>

---


❌ Напишите функцию polyfill для Promise.all

```js
const promiseAll = (proms: Promise<unknown>[]) => {
  // Answer
};

promiseAll([
  new Promise((res) => res("promise1")),
  new Promise((res) => res("promise2")),
  new Promise((res) => res("promise3")),
]).then((res) => console.log(res));
```

<details>
<summary>Ответ</summary>

const promiseAll = (proms) => {
  return new Promise((resolve, reject) => {
    proms.forEach(())
  })
};

</details>

---

❌ Напишите функцию polyfill для Promise.Race

```js
const promiseRace = (promises) => {
  // Answer
};
```

<details>
<summary>Ответ</summary>

</details>

---

❌ Напишите функцию polyfill для Promise.any

```js
function customPromiseAny(promises) {}

customPromiseAny([
  new Promise((res, rej) => rej("promise1")),
  new Promise((res) => res("promise2")),
  new Promise((res) => res("promise3")),
]).then((r) => console.log(r)); // promise2
```

<details>
<summary>Ответ</summary>

```js
function customPromiseAny(promises) {
  // Создаём счётчик промисов
  let errorPromises = 0;
  // Создаём пустой массив с длиной равной кол-ву промисов (надо для порядка результатов)
  const errors = new Array(promises.length);

  return new Promise((resolve, reject) => {
    // Создаём новый промис, в нём бежим по каждому промису
    for (let i = 0; i < promises.length; i++) {
      promises[i]
        .then(resolve) // Резолвим главный промис при первом попавшемся резолве дочернего
        .catch((error) => {
          errors[index] = error;
          errorPromises += 1;

          if (errorPromises === promises.length) {
            // Реджектим главный промис если все промисы зареджектились
            reject(promiseErrors);
          }
        });
    }
  });
}
```
</details>

---

✅ Необходимо реализовать жизненный цикл в хуке useEffect когда он монтируется и размонтируется. И если мы в зависимости будем передавать show и count, то когда он будет размонтироваться

<details>
<summary>Ответ</summary>

```js
console.log("Render")

useEffect(() => {
  return () => {
    console.log("Unmount")
  }
}, [show, count])

Если мы передали какую-то зависимость, то он срабатывается при первом рендеринге и когда меняется состояние.
```
</details>
