// Throttle — это функция, которая позволяет ограничивать частоту вызова другой функции fn. Эта функция полезна для обработки событий, например, resize окна, так как она генерирует множество событий за короткий промежуток времени.
//
//     Основные требования:
//     1.	Вызов функции fn происходит не чаще, чем раз в указанный delay миллисекунд.
// 2.	Первый вызов функции должен быть выполнен немедленно.
// 3.	Если произошел вызов, который был проигнорирован, то он должен быть выполнен последним после окончания delay.
//
//     Цель:
// Написать функцию throttle(fn, delay, ctx), которая возвращает новую функцию. Эту функцию можно использовать, например, в обработчике событий onWindowResize, где:
// •	fn — основная функция, которую необходимо вызывать.
// 	•	delay — время задержки между вызовами.
// 	•	ctx — контекст выполнения функции fn.
//
//

// Что хотим слышать - понимание асинхронности, понимание setTimeout


// Тестирование
function test() {
    const start = Date.now();

    function log(text) {
        const msPassed = Date.now() - start;
        console.log(`${msPassed}: ${this.name} logged ${text}`);
    }

    const throttled = throttle(log, 100, {name: 'me'});

    setTimeout(() => throttled('m'), 0);
    setTimeout(() => throttled('mo'), 22);
    setTimeout(() => throttled('mos'), 33);
    setTimeout(() => throttled('mosc'), 150);
    setTimeout(() => throttled('moscow'), 400);
    setTimeout(() => throttled('moscowwwwwwwwwwwww'), 4000);

    // Ожидаемый результат:
    // 0ms: me logged m
    // 100ms: me logged mos
    // 200ms: me logged mosc
    // 400ms: me logged moscow
}

console.clear();
test();


// ===================================================================

function throttle(fn, delay, ctx) {
    // Флаг, указывающий, нужно ли ждать перед следующим вызовом функции
    let needWait = false;
    // Переменная для хранения аргументов последнего вызова, который произошёл во время ожидания
    let lastArgs = null;
    function throttled(...args) {
        // Если мы в режиме ожидания, значит с момента последнего вызова не прошло delay мс
        // и мы не можем вызвать fn прямо сейчас.
        if (needWait) {
            // Запоминаем аргументы последнего вызова. Каждый новый вызов, пока needWait = true,
            // будет обновлять lastArgs, чтобы в итоге сохранить именно последний вызов.
            lastArgs = args;
            return;
        }
        // Если не нужно ждать, значит это либо первый вызов, либо прошёл delay
        // Вызываем функцию сразу
        fn.call(ctx, ...args);
        // Теперь мы вызвали fn, нам нужно подождать delay мс до следующего вызова.
        needWait = true;
        // Ставим таймер. По истечении delay мс мы разрешим следующий вызов,
        // и если за время ожидания были новые вызовы (хранятся в lastArgs),
        // мы вызовем fn ещё раз с последними переданными аргументами.
        setTimeout(function () {
            // Сбрасываем флаг ожидания, теперь снова можно вызывать fn немедленно.
            needWait = false;
            // Проверяем, были ли проигнорированные вызовы.
            if (lastArgs) {
                // Если были, вызываем throttled снова, но уже с отложенными аргументами.
                // Это обеспечит немедленный вызов fn, т.к. только что мы сбросили needWait.
                throttled.call(ctx, ...lastArgs);
                // После того, как мы обработали отложенный вызов, очищаем lastArgs.
                lastArgs = null;
            }
        }, delay);
    }
    return throttled;
}


// function throttle(fn, delay, ctx) {
//     let lastCall = 0; // Время последнего вызова функции
//     let timeout = null; // Таймер для выполнения следующего вызова
//     let lastArgs = null; // Аргументы последнего вызова
//     let lastContext = null; // Контекст последнего вызова
//
//     return function (...args) {
//         const now = Date.now();
//
//         // Если это первый вызов или прошло достаточно времени с последнего вызова
//         if (now - lastCall >= delay) {
//             // if (timeout) {
//             //     clearTimeout(timeout); // Удаляем запланированный таймер, если он был
//             //     timeout = null;
//             // }
//             lastCall = now; // Обновляем время последнего вызова
//             fn.apply(ctx, args); // Выполняем функцию с переданным контекстом
//         } else {
//             // Сохраняем контекст и аргументы последнего вызова
//             lastArgs = args;
//             lastContext = ctx;
//
//             // Если таймер еще не установлен, устанавливаем его
//             if (!timeout) {
//                 timeout = setTimeout(() => {
//                     lastCall = Date.now();
//                     timeout = null;
//                     fn.apply(ctx || lastContext, lastArgs); // Выполняем функцию с последними аргументами
//                 }, delay - (now - lastCall));
//             }
//         }
//     };
// }


