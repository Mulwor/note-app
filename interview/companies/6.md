### Что выведется

```js
(function() {
    var a = b = 3
})();
console.log(typeof a)
console.log(typeof b)
```

### Что выведется

```js
'use strict'
var obj = {
    i: 10,
    b: () => console.log(this.i, this),
    c: function() {
        console.log(this.i, this)
    }
}

obj.b()
obj.c()
```

### Что выведется

```js
var test = (function() {
    var value = 1;
    function setValue(newValue) {
        value = newValue
    }
    return {
        value: value,
        setValue: setValue
    }
})();
test.setValue(2);
console.log(test.value)
```

### Необходимо решить задачу

Есть последовательность числе 0, 1, 1, 2, 3, 5, 8. Первые два из них константы, а последующие это сумма функции. Подсказка - задача с фибоначи

```js
function code(value) {

}

// 1. Должно вывести все числа
for (let i = 1; i < 6; i++) {
    console.log(code(5))
}
// 2. 
code(8)                     // 5
```

---

### 1. Какой будет ответ: `console.log(typeof typeof 1)`

Typeof возвращает всегда результат в виде строки. Из чего можно сделать вывод, что typeof 1 вернет строку 'number', а затем typeof 'number' венет string

---

### 3. Какой будет ответ

```js
const userService = {
  currentFilter: 'active',
  users: [
    { name: "Alex", status: "active" },
    { name: "Nick", status: "deleted" },
  ],
  getFilteredUsers: function() {
    return this.users.filter(function (user) {
      return user.status === this.currentFilter
    });
  }
}

console.log(userService.getFilteredUsers())
```

Вернет пустой массив, так как внутри функции фильтр мы здесь объявили через function declaration и как раз внутри this потеряется. 

### 4. Какой будет ответ

```js
Promise.resolve(1)
  .then((x) => x + 1)
  .then((x) => { throw x } )
  .then((x) => console.log(x))
  .catch((err) => console.log(err))
  .then(x => Promise.resolve(x))
  .catch((err) => console.log(err))
  .then((x) => console.log(x))
```

Есть зарезвлоенный промис 1, мы идем к then получаем 2, затем выбрасываем ошибку после чего следующий then пропускаем и в блоке catch на пятой строчке мы как раз выводим и нашу двойку потому что мы ранее выбрасили двойку. После блока catch ошибка у нас считается обработанной по этому мы идем выполнения then. В следующем then у нас в качестве x ничего не передается и значит результат равен undefined. Блок catch пропускаем так как ошибок у нас нет и на последней строчке мы этот undefined выводим в консоль

### 5. Какой будет ответ

```js
const array = [1, 2, 3];
const array2 = array.map(item => item * 2).filter(item => item > 3);
const array3 = array.filter(item => item * 2 > 3);
console.log(array2, array3)     // [4, 6], [2, 3]
```

Array2 в начале все числа умножает на 2, а потом фильтрует их, если больше 3, то он оставляет эти числа. То есть ответ 4 и 6, 

В то время как в array3 происходит только фильтрация то есть условно 1 * 2 > 3 = 2 > 3 не попадает, 2 * 2 > 3 - попадает значит 2 оставляем а затем 3 оставляем

### 6. Какой будет ответ

```js
new Promise((resolve, reject) => {
    resolve(1);
    resolve(2);
    reject('error')
}).then(
    (value) => console.log(value),
    (error) => console.log('error')
)
```

Промис вызовется один раз и ответ будет зарезволенный 1, а последующие будут игнорировать, по этому и ответ 1

### 7. Какой будет ответ

```js
Promise.reject('a')
    .catch((p) => p + 'b')
    .catch((p) => p + 'c')
    .then((p) => p + 'd')
    .then((p) => console.log(p))

console.log('f')
```

В начале получаем зареджектный а, потом мы ловим catch и будет 'ab', следующий catch пропуск так как мы уже обработали ошибку, затем идем в then и выводим 'abd'

### 8. Какой будет ответ

```js
var b = 50;

function k() {
  console.log(b);
  if (true) {
    let b = 150;
    console.log(b);
  };
  console.log(b)
}

k();                // 50, 150, 50
```

### 8.1. Какой будет ответ

```js
var b = 50;

function k() {
  console.log(b);
  if (true) {
    var b = 150;
    console.log(b);
  };
  console.log(b)
}

k();                // undefined, 150, 150
```

Если внутри функции - `function k() {...}` у нас есть переменная объявленная var, то мы будем обращаться именно к ней. Если мы обращаемся к переменной до его инициализации то она будет равно undefined

### 8.2. Какой будет ответ

```js
var b = 50;

function k() {
  console.log(b);
  if (b) {
    var b = 150;
    console.log(b);
  };
  console.log(b)
}

k();                // undefined, undefined
```

b - не инициализирован и он не попадает внутрь

### 10. Что выведется

```js
(function() {
    var a = b = 3
})();

console.log(typeof a)       // undefined
console.log(typeof b)       // number
```

Переменная объявленная через var видны в рамках функции, у нас в данной записи переменная b становится глобальной, то есть считается что она объявлена без какого-либо ключевого слова

---

