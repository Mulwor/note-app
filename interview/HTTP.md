### HTTP

<details>
<summary>Что такое HTTP и как он работает?</summary>

HTTP (Hypertext Transfer Protocol)- протокол прикладного уровня. Он используется для обмена данными между клиентом и сервером. Например когда пользователь кликает на любую ссылку в браузере, то браузер отправляет HTTP-запрос на сервер, тот обрабатывает его, и отправляет HTTP-ответ
</details>

<details>
<summary>В чем отличие между HTTP и HTTPS?</summary>

Основное отличие заключается в безопасности, у HTTPS все данные передаются в зашифрованном виде, что защищает от перехвата информации от клиента, его кошелька и т.д.

Порты разные - у http 80, а у https 443

Когда мы пытаемся зайти на сайт с http-протоколом гугл сообщает, что данный сайт небезопасный.
</details>

<details>
<summary>Из чего состоит (структура) http-запроса?</summary>

Структура HTTP-запроса состоит из 4 кл.элементов: 

1. Стартовая строка состоит из методов (Get, post, put), пути (url) и версии протокола HTTP;
2. Заголовки (Headers) HTTP - метаинформация по типу, host, типа контента json;
3. Пустую строку (обязательный) - разделитель между заголовками и телом запроса
4. Тело запроса (необязательный) - используется для передачи данных на сервер, например, при использовании методов POST, PUT и PATCH
</details>

<details>
<summary>Какие есть методы в HTTP-запрос?</summary>

Всего 9 методов, разделяются они на основные и служебные.

1\. К основным относится - `Get (__для-получения-данных__)`, `post (__для-отправки-данных__)`, `put(__для-полного-обновления-данных__)`, `delete (__для-удаления-чего-либо__)`, `patch(__для-частичного-редактирования-данных__)`

2\. А к служебные: `Head (__для-получения-только-заголовков-(HEAD)__)`, `Options (____для-узнания-поддерживаемых-методов-и-политик-CORS__)`, `Trace(__для-диагностики-между-прокси-и-сервером__)`, `Connect(__для-подключения-к-HTTPS-через прокси__)` 
</details>

<details>
<summary> Что такое кеширование и какие методы у нас кешируется, а какие нет?</summary>

Кеширование - механизм, который сохраняет временно данные на стороне клиента, чтобы ускорить их последующую загрузку и снизить нагрузку на сервер. 

Кешуруемые методы - это GET, HEAD
</details>

---

<details>
<summary> Разница между GET- и POST-запросами?</summary>

1. `GET` используется для получения данных, а `POST` для отправки данных.
2. `GET` - индопотентен, а post нет
2. `GET`-запросы у нас кешируется, а `POST`-запросы нет.

Post можно закешировать на определенное время, если мы укажем если Cache-Control max-age=3600, но это не лучшая практика и браузер может заигнорировать кеширования

3. Если говорить про передачу данных, то у `GET` параметры передают в url-строке, а у `POST` в теле запроса body
</details>

<details>
<summary>Разница между PUT- и POST-запросами?</summary>

1. `PUT`-запрос необходим для обновления уже существующих данных или если этих данных нет, то для создания новых данных а `POST` для создания чего-то нового либо отправки каких-то данных

2. `PUT`-запрос идемпотентен, в то время как `POST`-запрос нет. Идемпотент означает, что каждый раз когда мы делаем одно и тоже действия мы ожидаем одинаковый результат, однако у поста каждое отправления создается новый результат
</details>

<details>
<summary>Расскажите про коды состояния?</summary>

1\. `1xx` - носит информационный характер, например сервер получил headers (заголовки) твоего запроса и готов принять тело. Продолжай отправку;

2\. `2xx` - запрос был успешно выполнен;

3\. `3xx` - перенаправления, теперь сайт находится по новому адресу;

4\. `4xx` - ошибка на стороне клиента, запрос не тот передали или еще что-то;

5\. `5xx` - ошибка на стороне сервера
</details>

<details>
<summary>В чем разница между HTTP/1.1, HTTP/2 и HTTP/3</summary>

1. В первой версии HTTP данные передавались в виде текса, а это в свою очередь увеличивало размер и загрузку, во второй версии уже используются фреймы, разделяя запрос и ответ на маленькие управляемые фреймы

2. В первой версии не было Сжатия и все передавалось как есть, во второй же сживаются заголовки

3. В первой версии не было мультипликисирование - это когда на одном соединнения можно было отправлять несколько запросов, оно появилось во второй. В первой нужно было открывать несколько соединений

А в 3 версии решается проблема Head-of-Line Blocking, если во второй версии потеря одного пакета тормозил все потоки, то в 3 версии каждый поток независим и пакеты в одном не влияет на другие
</details>

<details>
<summary>Что такое HTTP cookie? Для чего они используются?</summary>

HTTP cookie – это небольшие фрагменты данных (каждый до 4 КБ), которые хранятся в браузере пользователя и отправляются в каждом запросе. Обычно они устанавливаются сервером с помощью заголовка Set-Cookie, но могут создаваться и через JavaScript. Количество кук на один домен ограничено (обычно 100-180 в современных браузерах). Время жизни куков можно сделать временным, пока пользователь не закроет браузер, или постоянным, там по стечению определенного времени через max-age

Куки используются для:

- управления сеансом - логины, корзины с покупками;
- мониторинга - отслеживания поведения пользователей;
- Предпочтения пользователей (персонализация) - язык интерфейса, тема;

</details>

---

<details>
<summary>Что такое веб-хранилище (web storage) и разница между sessionStorage и localStorage?</summary>

Web-storage - это инструмент, который позволяет хранить данные в браузере в виде: ключ и значение. 

Существует два вида хранения информации: sessionStorage (данные хранятся пока в браузере не закроем вкладку) и localStorage (данные хранятся пока не исякнет период хранения либо пока не отчистим кеш) 

Если мы откроем рядом еще одну session storage то данные будут создаваться снова, в отличии от local storage, который доступен из любой вкладке.

Доп.вопросы:

1. А как вы будете хранить объект в localStorage? - При записи JSON.stringify(), а при чтении JSON.parse(), так как апи работает только со строками

2. Что произойдёт с localStorage в режиме инкогнито? - Будет работать, но все данные удаляться после закрытия всех вкладок приватного режима

3. В чём основное отличие от Cookies? - Мы не отправляем на сервер каждый HTTP-запрос, у  нас нет жесткого ограничения 4KB

4. Как обработать ситуацию, если localStorage переполнен? - Браузер выбросит исключения QuotaExceededError, если у нас localStorage переполнен. Для обработки нужно обернуть вызов setItem() в блок try...catch и в блоке catch проверить error.name === 'QuotaExceededError'."
</details>

<details>
<summary>Что такое CORS? </summary>

CORS (Cross-origin resource sharing) — это механизм браузера, который с помощью специальных HTTP-заголовков позволяет странице получить доступ к ресурсам с другого домена. 

Он нужен, чтобы безопасно обойти строгое правило Same-Origin Policy. Чтобы это работало, сервер должен в своих ответах отправлять заголовки, например, Access-Control-Allow-Origin, а для сложных запросов браузер сначала делает предварительный OPTIONS-запрос

</details>

<details>
<summary>Что такое WebSocket? В чем принцип его работы?</summary>

WebSocket - протокол для постоянного обмена данными между браузером и сервером в реальном времени без постоянных перезапросов. Например вебсокеты используются - в чатах, на сайтах обменников криптовалюты, в онлайн играх и т.д.

Стоит отметить, что он отличается HTTP тем что, HTTP работает по модели запрос-ответ, в то время как вебсокет устанавливает двустореннее соединения, где сервер сам отправляет данные в любой момент времени
</details>


<details>
<summary>Что такое аутентификация, авторизация и логинизация?</summary>

`Логинизация` - ввод логина и пароля для входа в систему
`Аутентификация` - процесс проверки пользователя, сравнивается логин и пароль который ввел пользователь и если он совпадает с их базой данный, то дает доступ
`Авторизация` - процесс прав пользователя. Грубо говоря что может человек делать, а что нет

</details>

<details>
<summary>Что такое JWT-токен, где он хранится?</summary>

Во время аутентификации, когда происходит проверка логина и пароля с базой данных, то он отправляет JWT-токен. Этот токен на фронте мы должны обработать и если он имеется, то дать доступ ко входу в личный кабинет
</details>