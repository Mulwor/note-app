- [Что такое nestjs?](#nest-js)
  - [Установка, структура и запуск nestjs](#install-nest-js)
  - [Архитектура приложения - модули, контроллеры, сервисы](#architecture-nest-js)
  - [Генерация сущностей в nest.js](#generation-entity-in-nest-js)
  - [Работа с декораторами REST API](#workInDecorators-in-restAPI)

<a id="nest-js"></a>
<h2 align='center'>Что такое nestjs?</h2>

Nest (NestJS) — это фреймворк для создания эффективных и масштабируемых серверных приложений на Node.js. Он использует прогрессивный JavaScript, построен на TypeScript и полностью его поддерживает (при этом позволяя разработчикам писать код на чистом JavaScript), а также сочетает в себе элементы объектно-ориентированного программирования (ООП), функционального программирования (ФП) и реактивного функционального программирования (РФНП).

В основе Nest лежат мощные фреймворки для HTTP-серверов, такие как Express (по умолчанию), а также, при желании, его можно настроить на использование Fastify! Nest обеспечивает уровень абстракции выше, чем у распространенных фреймворков Node.js (Express/Fastify), но при этом напрямую предоставляет разработчику доступ к их API. Это дает разработчикам свободу использовать множество сторонних модулей, доступных для базовой платформы.

Nest предлагает готовую архитектуру приложений, которая позволяет разработчикам и командам создавать приложения, легко тестируемые, масштабируемые, слабо связанные и простые в обслуживании. Архитектура во многом вдохновлена ​​Angular.

<a id="install-nest-js"></a>
<h2 align='center'>Установка, структура и запуск nestjs</h2>

1\. В начале необходимо глобально установить nestjs => `npm i -g @nestjs/cli`, затем проверяет установлен ли он `nest --version`;

2\. Затем переходим в папку где хотим работать с nest и пишем команду: `nest new nestjs`, где nestjs - это названия репозитория. Данная команда создает нам приложение на nestjs. После того как мы написали команду, у нас идет выборка пакетного менеджера: `Which package manager would you ❤️ to use? - npm, yarn, pnpm` и после выбора происходит установка nest и собираются зависимости нашего предложения. И в конце увидим вот это сообщение - `Thanks for installing Nest`
3\. Запускаем приложением переходя на него `cd nestjs` и `yarn run start` 

<h3 align='center'>Базовая структура приложения</h3>

1\. tsconfig.json необходим для typescript;

2\. tsconfig.build.json нужен для настройки typescript когда у нас проект соберется;

3\. README.md;

4\. package.json содержит список зависимостей и какую-либ информацию о проекте;

5\. nest-cli.json где можно настроить различные параметры нашего приложения;

6\. eslint.config.mjs - настройки еслинта;

7\. .prettierrc - настройки форматирования;

8\. .gitignore - файлы которые необходимо игнорировать при публикации на репозиторий;

9\. src - главная папка нашего проекта (controller, module, service), где app.controller.ts главный контроллер нашего приложения, где app.module - это главный модуль предложения в котором мы все будем объединять все остальные модули нашего предложения (модуль авторизации, для продуктов и прочее), и app.service.ts - располагается различная бизнес-логика, а также есть app.controller.spec.ts, где просто есть тесты для нашего контролера и main.ts - основной файл нашего приложения

```js
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  // Главная функция, в которое инициализируем наше приложение,
  // прокидываем главный модуль и указываем что он будет на порту 3000
  // либо которое берет из env и будет запускаться
  const app = await NestFactory.create(AppModule);
  await app.listen(process.env.PORT ?? 3000);
}
bootstrap();
```
10\. test

<h3 align='center'>Запуск приложения</h3>

Для того, чтобы запустить проект необходимо написать `yarn run start:dev` либо `npm run start:dev` в зависимости какой был выбран пакетный менеджер; заходим в гугл и вбиваем в адресную строку - http://localhost:3000/; затем идем в `src/app.service.ts` там и содержится наш hello world. Если захотим возвращать в формате json, то переписываем так

```js
// src/app.service.ts
getHello() {
   return { message: "Welcome to nest js course" } 
}

// src/controller.ts
@Get()
getHello() {
  return this.appService.getHello();
}
```

<a id="architecture-nest-js"></a>
<h2 align='center'>Архитектура приложения</h2>

Каждый элемент приложения выполняет свой роль, что позволяет легко масштабировать проекты, поддерживать его в долгосрочной перспективе. Главное строительное приложение в nest-js - модули, контроллеры и сервисы


<h3 align='center'>Модули</h3>
Модуль в nest-js - это контейнер, который группирует все компоненты для решения конкретных задач. Проще говоря модуль это как часть приложения, которая отвечает за определенную область функционала. Например если вы делается систему с работы с пользователями, то модуль будет выглядеть так

```js
@Module({
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}
```

Здесь мы видим, что модуль UsersModule включает в контроллеры сервис, которая отвечает за работу с пользователями. Модули помогают организовать код, не позволяя всему перемещиваться в одну кучу

<h3 align='center'>Контроллеры</h3>
Контроллеры - это те компоненты, которые принимают входящие http-запросы и передают их на обработку сервисам. Они не занимаются логикой обработки данных, а только направляют запрос туда где это логика уже есть, это позволяет разгрузить контроллеры и сосредоточить всю бизнес логику в сервисах. 

```js
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Get()
  getUsers(){
    return this.usersService.getUsers()
  }
}
```

Когда происходит get запрос на получения всех пользователей, контроллер вызывает метод getUsers из нашего сервиса и тот уже занимается списком получения пользователей. В итоге контроллер просто принимает запрос и отдает нам результат.

<h3 align='center'>Сервисы</h3>
Сервисы - это мозг вашего приложения, когда контроллер получает запрос от клиента, он делегирует всю работу сервису. Сервисы занимаются такой логикой - взаимодействуют с базой данных, проверяют данные, обрабатывают ошибки и решают что делать дальше. То есть контроллер сам по себе не выполняет никакой бизнес-логики, его задача лишь передать в нужное место, а сервис уже все решит. 

```js
@Injectable()
export class UsersService {
  private users = [
    { id: 1,  name: "Alice" }, 
    { id: 2,  name: "Bob" }, 
  ];

  getUsers() {
    return this.users;
  }
}
```

В примере сверху сервис просто возвращает массив пользователей, в реальном приложение сервис просто взаимодействует с базой данных при различных orm - prisma или typeorm

В реальном приложение эти элементы работают следующим образом - все начинается с запроса от клиента, он отправляет запрос на получения списка пользователей, запрос должен быть обработан контроллером, который передаст его в сервис, а сервис уже сделает всю свою работу и вернет нам результат

<a id='generation-entity-in-nest-js'></a>
<h2 align='center'>Генерация сущностей в nest.js</h2>

Сущность - модуль, сервис, контроллер. Для генерации сущностей необходимо написать в терминале команду `nest generate resource task` или `nest g res task`, где resource - указания на сущность, а task это названия сущности в единственном числе, нажимаем на enter и нам предлагают выбрать - транспорт, который будем использовать:

`What transport layer do you use? - REST API, GraphQL (code first), GraphQL (schema first), Microservice (non-HTTP), websockets` - Выбрали например REST API и получаем следующую команду:

`Would you like to generate CRUD entry points? (Y/n)` - хотим ли мы генерировать CRUD энтри поинтсы. При нажатие на Y, у нас уже будут в сервисе описаны какие-то методы, dto (входные параметры). Выбираем n, так как хотим отказать от установки. И в левой части - `src/task` замечаем установку сущностей.

Стоит отметить, что у нас сгенерировалось все сущности включая тесты, если мы не хотим генерировать тесты, то используем флажок --no-spec => `nest g res task --no-spec`

Отличительной чертой также является что если в `src/app.controller` у нас в контроле было пусто, то в `src/task/task.controller.ts` присвоится значения `@Controller('task')`, и в app.module.ts (основной) добавился импорт task

<a id='workInDecorators-in-restAPI'></a>
<h2 align='center'>Работа с декораторами REST API</h2>

В данном разделе будут рассматриваться все способы создание REST API запросов. И начнем  с классического get-запроса

<h2 align='center'>Получение всех тасок через get-запрос</h2>

В NestJS контроллере создайте функцию findAll(), которая будет брать таски из сервиса и пометьте декоратором @Get(), чтобы обрабатывать GET-запросы. Всю бизнес-логику выносится на сервис.

```ts
// src/task/task.controller.ts
import { Controller, Get } from '@nestjs/common';
import { TaskService } from './task.service';

@Controller('task')
export class TaskController {
  constructor(private readonly taskService: TaskService) {}

  @Get()
  findAll() {
    return this.taskService.findAll();
  }
}
```

```ts
// src/task/task.service.ts
import { Injectable } from '@nestjs/common';

@Injectable()
export class TaskService {
  private tasks = [
    { id: 1, title: "Learn NestJS", isCompleted: false },
    { id: 2, title: "Build API", isCompleted: true },
  ];

  findAll() {
    return this.tasks;
  }
}
```

Потом в терминале пишем yarn run start:dev и видим путь в терминале => `[Nest] 18648 - 09.01.2026, 19:16:29 LOG [RouterExplorer] Mapped {/task, GET} route +0ms`, что означает что по данному запросу у нас создался REST Api, открываем `localhost:3000/task` и получаем результат массив с двумя объектами. 

<h2 align="center"> Получения таски по id через Get-запрос </h2>

Для того, чтобы получить таску по id необходимо написать функцию findById, который принимает в себя id, а в контроллере обратится к ней. 

```js
// src/task/task.service.ts => после findAll
findById(id: number) {
  const task = this.tasks.find((task) => task.id === id)

  // Стоит также обработать ошибку если таски нет - это 404
  if (!task) {
    throw new NotFoundException('Task not found');
  }

  return task
}
```

```ts
// src/task/task.controller.ts => после findAll
// Можно захордкодить
@Get()
findById() {
  return this.taskService.findById(1)
}

// Или получить из ссылки браузера, установив в качества аргумента param и
// в нем указав название нашего параметра и указываем что это id с типом 
// number и этот id прокидываем внутри 
@Get('by-id/:id')
findById(@Param('id') id: string) {
  return this.taskService.findById(Number(id))
}
```

<h2 align="center"> Отправка таски через post-запрос</h2>