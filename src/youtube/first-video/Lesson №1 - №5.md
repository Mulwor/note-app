Lesson №1

1. Для чего нужен redux (стейт-менеджер)?

Стейт менеджер нужны для того, чтобы работать с состояниями, которые не зависят от структуру интерфейса и не зависит от жизненного цикла интерфейса. Живут за пределы
его и к нему может подключится любой компонент куда вы хотите его записать и прочитать.

2. Базовые концепции redux:

- redux-store - живет во вне компонентов. Это хранилища объект, который внутри себя хранит состояние и каким-то образом предоставляет инструменты работы с ним. Другими словами это обертка над состоянием, которая регламентирует управление этим состоянием;
- Внутри редакс-стора есть reducer, которая должна вернуть нам состояние. Все возможные наборы изменения заложен только в редьюсер. Редьюсер - чистая функция, которая принимает предыдущая состояние и action и возвращает новое состояние;
- С помощью action, стор понимает когда нужно изменить состояние. Action - обычные js объекты, который наш компонент может положить в наш стор с помощью вызова на него метод dispatch. А вот каким образом будет отвечать изменения состояние отвечает reducer. Особенность редакса то, что он сам контролирует то каким образом изменить состояние при воздействие action который отправляет компонент;
- И компонент может прочитать это с помощью двух методов: getState(получить эти данные), а subscribe - узнавать когда эти данные меняются

---

Lesson №2

3. Reducer

Reducer должна быть чистая функция - другими словами у него нет сайд-эффектов и что она детерминированная. Например если наша функция берет параметры и как-то мутирует в нем значение - это сайд-эффект. Детерменирования означает, что редюсер не может
считать не из каких внешних сторов - мутабельных. Это означает, что каждый раз функция при одних и тех же параметров всегда возвращает одно и то же значение не
зависимо от состояние предложения

Иммутабельность - это когда мы принимаем состояние, меняем в нем нужные нам поля, создаем новый объект с нужными полями. И уже это новое состояние будет записано в стор внутри предыдущего

Зачем нужна иммутабельность:

1. Гарантия того, что данные не изменятся - История изменений
2. Возможны чистые функции
3. Redux использует для оптимизации

Для того, чтобы узнать изменилось ли поле внутри иммутабельного изменения необходимо
сравнить ссылки на эти поля

Селектор - чистая функция которая принимает state и возвращает его

---

Lesson 3 

Когда мы устанавливаем react-redux - нам необходимо
main.tsx обернуть в Provider. Он нужен

Несколько правил

1. Нужно выбирать как можно меньше данные, чтобы наш компонент
перерисовался как можно меньше.

2. Нужно чтобы сложность алгоритмов внутри была маленькая

3. Не нужно создавать новые ссылки внутри селекторов если конечно они не мемозированны

--- 

- Когда мы используем селектор, то необходимо иметь сложность О(1)

Например у нас c бека приходят данные и нам необходимо отрисовать
определенные данные. Если мы решим использовать это:
```
const user = useAppSelector(state => state.users.find(user => user.id === userId))
```
то уровень сложности будет O(n)

Лучше избегать данного метода и использовать следующею конструкцию, что приведет к уровню сложности О(1)

```
type UsersState = {
  entities: Record<UserId, User | undefined>;
  ids: UserId[];
}

const counter = useAppSelector(
  state => state.users.entities[userId];
)

```

- Не создавать ссылки внутри селекторов

```
const sortedUsers = useAppSelector(
  state => state.users.toSorted(sortFn)
)
```
Вместо этого можно использовать

```
const users = useAppSelector(
  state => state.users
)

const sortedUsers = useMemo(
  () => users.toSorted(sortFn),
  [users]
)
```

```
const selectUserById = createAppSelector(
  state => state.users,
  (_, userId: UserId) => userId,
  (users, userId) => users.find(user => user.ud === userId)
)

const user = useAppSelector(state => selectUserById(state ,userId))
```

combineReducer - помогает объединить несколько reducer в один общий. Lesson №4 ==> №5

Есть два принципа разделение Store на модули:

- low coupling - между нашими модулями должно быть как можно меньше связей
- high cohesion - для того, чтобы модули хорошо читались, воспринимались они должны быть про одно и тоже. Они должны хорошо быть связаны к друг другу и должны реализовать одну конкретную функциональность