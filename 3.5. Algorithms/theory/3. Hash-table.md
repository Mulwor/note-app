<h2 style="text-align: center">Map</h2>

Map – это коллекция ключ/значение, как и Object. Но основное отличие в том, что Map позволяет использовать ключи любого типа. У него есть следующие методы:

```
const map = new Map();          // Создает коллекцию

map.set("1", "str1");           // map.set(key, value) – записывает по ключу key значение value.
map.set(1, "num1");
map.set(true, "bool1");

map.get(1);                     // возвращает значение по ключу или undefined, если ключ key отсутствует: "num1"
map.get("1");                   // "str1"

map.size;                       // возвращает текущее количество элементов. ===> 3

map.has('job');                 // возвращает true, если ключ key присутствует в коллекции, иначе false ===> false
map.has(1)                      // true

map.delete('job');              // удаляет элемент (пару «ключ/значение») по ключу key.

map.clear();                    // очищает коллекцию от всех элементов.
```

<h3 style="text-align: center">Перебор map</h3>

```
let recipeMap = new Map([
  ["огурец", 500],
  ["помидор", 350],
  ["лук",    50]
]);

for (let vegetable of recipeMap.keys()) {        // перебор по ключам ===> огурец, помидор, лук
  console.log(vegetable);                                    
}

for (let amount of recipeMap.values()) {         // перебор по значениям ===> 500, 350, 50
  console.log(amount);                        
}

for (let entry of recipeMap.entries) {           // перебор по элементам в формате ключ, значения  ===> огурец,500 (и так далее) 
  console.log(entry);                                         
}

```
<h3 style="text-align: center">Преобразование в объект</h3>

```
let mapToObject = new Map();
mapToObject.set('banana', 1);
mapToObject.set('orange', 2);
mapToObject.set('meat', 4);

let obj = Object.fromEntries(map.entries());    // obj = { banana: 1, orange: 2, meat: 4 }

console.log(obj.orange); // 2
```

<h2 style="text-align: center">Set</h2>

Объект Set – это особый вид коллекции: «множество» значений (без ключей),  где каждое значение может появляться только один раз.

```
let set = new Set();          // Создаем Set – коллекция уникальных значений, так называемое «множество».

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };
set.add(john);                // set.add(value) –  добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект set.
set.add(pete);
set.add(mary);
set.add(john);
set.add(mary);

console.log(set.size)         // возвращает количество элементов в множестве. ===> 3
set.delete(john)              // удаляет значение, возвращает true, если value было в множестве на момент вызова, иначе false.
set.has(john)                 // возвращает true, если значение присутствует в множестве, иначе false.
set.clear()                   // удаляет все имеющиеся значения.
``` 

<h3 style="text-align: center">Перебор set</h3>

```
let recipeSet = new Set(["апельсин", "яблоко", "банан"]);

for (let value of recipeSet) {
  console.log(value)
}

recipeSet.forEach((value, valueAgain, set) => {
  console.log(value);
});

Set имеет те же встроенные методы, что и Map:

set.values() – возвращает перебираемый объект для значений,
set.keys() – то же самое, что и set.values(), присутствует для обратной совместимости с Map,
set.entries() – возвращает перебираемый объект для пар вида [значение, значение], присутствует для обратной совместимости с Map.
```

<h2 style="text-align: center">weakMap и weakSet</h2>

WeakMap и weakSet - должны быть объектами в отличии от классических map/set у которого может выступать в качестве примитива

```
let weakMap = new WeakMap();
let obj = {};
weakMap.set(obj, "ok");                // ! Work
weakMap.set("test", "Whoops");         // ! Don't work
```

Второе отличие он не поддерживает перебор - keys, values, entries. Так что нет способа взять ключи от туда

У weakMap есть только 4 метода: `weakMap.get(key), weakMap.set(key, value), weakMap.delete(key), weakMap.has(key)`

Как и Set, она поддерживает `add, has и delete`, но не `size, keys()` и не является перебираемой.
