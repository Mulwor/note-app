В основе effector лежит 3 простых базовых сущностей: 

1. `Хранилище (Store)` — это место, где мы храним наши данные. Его необхадимо оборачивать в $: 
```
const $user = createStore({})
```

Методы, которые есть в сторе: 
- `on (trigger, reducer)` - обновляет состоянии при вызове с помощью редюсера, а он в свою очередь - 
функция, которая получает состояние (параметры) и возвращает новое состояния (он должен быть чистым). У него не должно быть значения undefined, если поставить его то он не обновит состояние

- `map (fn: (state: State, lastState?: T) => T, firstState: T)` - создает производное хранилища. Работает следующим образом: будет вызываться функция (fn) с состоянием в том случае, когда обновится сам стор. И будет дан ответ обновленного стора 


2. `Событие (Event)` — это действие, которое каким-то образом модифицирует хранилище. Особенность (необзятельная) состоит в том, чтобы называть события, которые напрямую запускают обновления 
хранилища.

```
const emailChanged = createEvent()
```

3. `Эффект (Effect)` — это асинхронное действие, связанное с хранилищем. К его особенностью служит Fx в конце. Также внутри него может handler (функция), которая необходимо для обработки вызово эффектов. 
```
const fetchUserFx = createEffect({})
```

Методы, которые есть в effect: 
- `doneDate` - событие, которое срабатывает при успешном выполнения эффекта


4. Другие методы в эффекторе: 

- `combine` - получаем состояния каждого стора (хранилища) и объединяет (соединяет) это в одно значение и сохраняет все в общий один общий стор, что обновляется каждый раз.

- `(sample ( { source?, clock?, filter?, fn?, target?*} ): target)` - это объединения стор с эффектом через event. Когда сработает эвент, заюзаецца эффект и к нему примениться стор

```
sample({
  
  // Если clock не выполнется успешно, то sample будет вызывать на каждое улучшения saurce
  clock: submitted,
  source: $form,
  
  // Если target не выполнится успешно, то он создаст его и вернет значения из функции sample
  target: sendFormFx,

})
```



<details>
<summary> На будущее </summary>

* unit - Тип данных, используемый для описания бизнес-логики приложений 
* sample => тип: массив =>
* source => тип: объект и массив со стором =>
* clock => тип: массив
* filter => у функций или сторов => если у функции или стора вернется значение true, то он продолжит выполнения, если false, то не продолжится
* fn => функция => так называемый комбинатор функция, это когда данные преобразуется из source и clock перед передачей их целевому объекту, должна быть чистой. Если успешно не преобразуется то данные из saurce перейдут в target как есть
* target -
</details>
