Node-js - это среда выполнения js-кода на сервере. У него есть особая среда, например когда вы можете писать js-код, который будет взаимодействовать с файловой системой, с операционной системой благодаря которой мы можем, использовать js-код не только в браузере. 

<details>
<summary>Зачем нужен node-js?</summary>

1. Когда мы хотим построить input, output - интенсивное приложение. Это означает, что есть задачи, которые не имеют так много вычислений, но при этом очень много данных идет на вход и много нужно отдавать на выход. Например - API (что-то отдают на фронт, получают с него запросы, делают несложные действия - достать что-то из базы, что-то туда записать и отдают на фронт результат)
2. Когда мы хотим отдавать какие-то данные по частям (data streaming applications) - например мы можем отдавать видео, какие-то другие данные в потоке
3. CLI (Command line interface) - applications - это интерфейс командной строки. Если нам не нужен UI, и какая-то красивая графика и мы хотим чтобы наше приложение выполняло какие-то действия
4. IoT (Internet of things) - устройство для умного дома, которое контролирует освещение, для контроля температуры в доме, включения лампочек и т.д. А в node-js он используется для применения в микроконтроллерах
5. Cloud - если мы захотим использовать такие cloud провайдеры как Amazon Web Services или google cloud platform и microsoft azure, то с помощью него (node.js) мы можем писать лямбды функции, и мы можем писать приложения, которые там будем разворачивать 
</details>

<details>
<summary>Какие есть ключевые особенности node-js?</summary>

1. Среда выполнения кода - JavaScript
2. Node-js использует внутри себя движок V8, также как и следствия используется JIT (just in time compilation) - за счет чего он очень быстро компилирует вот этот код и начинает его выполнять
3. Node-js однопотопная среда выполнения. Есть среды выполнения кода, которые для выполнения одного запроса создается отдельный поток, в котором это выполняется, но у него есть ряд недостаткой по типу увеличения памяти, ресурсов и прочее. А у node-js это однопоточная среда выполнения, которая нам доступен по умолчанию и внутри него есть eventloop, который позволяет handlit определенные события и очень важно его не блокировать
4. Node-js кроссплатформенная среда, которая позволяет писать код который будет выполняться на разных операционных системах, устройствах (компьютер, телефон, микроконтроллер)
5. Node-js построено на событиях, которая использует Event driven архитектуру
6. Также он является очень хорошо скалирующимся (scalable) и масштабирующимся как раз за счет того, что можно создавать новые инстансы приложения с помощью дочерних процессов, можно создавать отдельные потоки, можно масштабировать API с помощью класстера
7. В нем также богатый API * прикладной программный интерфейс - в нем есть большое кол-в строенных модулей благодаря которым уже имеется готовый функционал
</details>

<details>
<summary>Модули в node-js</summary>
Материал взят от сюда: https://www.youtube.com/watch?v=RXFOAqsWzFA

Node-js считает любой файл - модулем и существует несколько способов как писать эти модули. Модули - это такой способ организации кода когда отдельный какой-то функционал помещается в отдельный файл и соответственно содержимое этого файла оно экспортируется / импортируется в другие файлы (модули). 

<details>
<summary>Основные преимущество использование модулей:</summary>

- Кодовая база делится на различные файлы, что упрощает понимание каждого куска кода;

- Облегчается переиспользование кода - если модуль написан правильно, то есть он в себя принимает какие-то входные данные, он что-то с ними делает и отдает какие-то выходные данные;

- Изоляция кода и его сокрытия - мы знаем, что модуль требует для своей работы, что отдает и внутри он что-то делает, но если это хорошо написанный модуль, то по сути не важно как реализованно именно его внутренний код. И удобно нам как скрывать эту функциональность и изолировать;

- Модули позволяют нам лучше управлять зависимостями;
</details>

<details>
<summary>Какие модули бывают</summary>

<details>
<summary>IIFE с примером кода</summary>


```
const IIFE_module = (() => {
  let innerVariable = 'Secret value!';

  const publicInterface = {
    getValue() {
      return innerVariable;
    },
    setValue() {
      if (typeof newValue === 'string') {
        innerVariable = newValue;
      } else {
        innerVariable = "DEFAULt"
      }
    }
  }

  return publicInterface
})();

console.log(IIFE_module.getValue())

IIFE_module.setValue('new str')
console.log(IIFE_module.getValue())

IIFE_module.setValue(12334)
console.log(IIFE_module.getValue())
```
</details>

<details>
<summary>CommonJS</summary>

- CommonJS, где импорт используется в форме require(moduleName) а export используется через export или module.exports. Под капотом у require - объект с методами.

Сходства между export и module.exports, они оба возвращают пустой объект, а разница между ними:

Перезаписывания имени: `export = 'string'` - он не найдет модуль, и вернет пустой объект, а вот так `export.a = 'string'` - при вызове он уже найдет его. А в модуле экспорте такого нет, он вернет значение и не нужно придумывать махинаций

Асинхронная функция `require(moduleName)` - вначале ищет внутри проекта модуль, в случае если через пути относительные и абсолютные не находит, то идет выше например require ('fs'), в случае если и там он не находится то идет искать в modules, если и там не обнаружит то он пойдет еще в глобальные искать 

Модуль загружается только 1 раз, дальше он кешируется (сохраняется значение, и вместо того, чтобы повторно его вычислять или откуда-то получать по запросу - мы берем его из кеша сохранную)
</details>

<details>
<summary>ESM (EcmaScript modules)</summary>

Какие есть способы установки EcmaScript модулей? 

1. Можно ко всем файлам вместо js установить .mjs и у нас будет использоваться import
2. В package.json написать type и выбрать "module" - так он будет понимать, что мы используем модули
3. Через терминал написав node --input-type=module nameFile

Есть несколько видов импортов 

1. `import default from "module-name";` - дефолтный экспорт
2. `import * as name from 'module-name'` - возьмется все импорты и запишется в переменную name
3. `import { name_01, name_02 as Loge } from 'module-name'` - импорт с деструктиризацией и запись в переменную Loge
4. `import defaultExport, { export [, [...] ] } from module-name` 
5. `import module-name` по типу `require('./')`;
6. Динамические импорты: `import("/module-name.js").then(module => {...}).catch(error => {})`

Есть несколько видов экспорта: 
1. Классический экспорт `const a = 2
export { a }` и экспорт переменной через `export const a = 2`;
2. Переименовка экспорта `export { a as name, b }; import { name } from 'name-file';`
3. Экспорт по дефолту - когда нам необходимо экспортировать определенную функцию - `export default const a = 1` или просто `export default a`.
4. Можно экспортировать одно по умолчанию, а другие нет - `export { a as default, b, c}`

Как работают импорты, они имеют 3 фазы:
1. Construction (parsing) - в ней ищутся все импорты модулей и рекурсивно загружается контент со всех модулей
2. Instantiation - для каждой сущности сохраняется именованная ссылка в памяти, но в ней пока не привязываются какие-то значения. Они помогают взаимоотношения между импортами
3. Evaluation - фаза выполнения. На этой фазе node берет и выполняет код всех этих сущностей инстанцированных используя вот эти связи и после этого у нас возможен запуск кода в загружаемом модуле. Потому что все вычисления были выполнены. 

Ключевые особенности:
1. Native JS modules (через import)
2. Импорт асинхронный 
3. Импорты не работают в блоках кода
4. this будет undefined
5. Есть imports.meta
6. Нет default __dirname, __filename, require, exports, module. Но заменить можно след.образом dirname:

```
import { fileURLToPath } from 'url';
import { dirname } from 'path'; 

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename)
```

Аналог require: 

```
import {createRequire} from 'module'

const require = createRequire(import.meta.url);
```

7. Ecmascript modules такие же как в браузере
</details>
</details>

<details>
<summary>Модульная система</summary>

Node.js использует модульную систему. То есть вся встроенная функциональность разбита на отдельные пакеты или модули. Модуль представляет блок кода, который может использоваться повторно в других модулях. А так модули делятся на 3 типа: 
1. `Packages (3-rd party)` - внешние модули, которые мы устанавливаем;
2. `Core modules (built-in)` - это модули которые установлены по умолчанию внутри node-js, например мы импортируем их - fs, streams и.т.д.; 
3. `Модули собственно кода` - когда мы пишем приложение на node.js мы реализуем функционал в виде какого-то кода и этот код разделяется по файлам, соответственно и эти файлы будут являться модулями

Вот некоторые примеры методов модулей:

<details>
<summary>Process</summary>

Process - предоставляет полные данные о системе, параметрах запуска, переменных окружении и потребялемых процессом ресурсах. Он глобальный и импортировать его не стоит

1. `process.pid` - получить id текущего процесса в котором запускается node-js;
2. `process.argv` - получаем аргументы командной строки с которым было запущено  приложение;
3. `process.report.writeReport()` - получаем отсчет нашего процесса - о том сколько он употребляет памяти, в каком окружении он работает;
4. `process.on("SIGTERM", () => {...})` - можем подписываться на системные сигналы;
5. `process.exit()` - можем завершить текущий процесс;
</details>

<details>
<summary>Events</summary>

Позволяет реализовывать API, подписки на события и их эмита. EventEmitter() - это такая сущность, которая позволяет подписываться на события и их емитить. 

```
const EventEmitter = require('events');
const calculator = new EventEmitter();
calculator.on('sum', (a, b) => console.log(`Result is ${a + b}`))
calculator.emit('sum', 1, 3 )
```

</details>

<details>
<summary>File system (файловая система)</summary>

File system (файловая система) - представляет собой абстракцию в node-js файловых систем вашей хостовой машины и позволяет вам выполнять различные полезные операции. Например получения информации о файла 

```
const fs = require('fs/promises');
const fileStats = await fs.stat('photos/cute/funny-cat.jpg');

console.log(fileStats.isFile())    // ? Проверка на является ли файл - файлом?
console.log(fileStats.size)        // ? Размер файла в битах
console.log(fileStats.birthname)   // ? Дата создания файла
```

</details>

<details>
<summary>Streams</summary>

Streams - когда мы используем некий интерфейс для того, чтобы работать с данными по частям - не читать сразу весь файл, а разделить его на части. Например когда мы хотим прочитать данные из request-body, записывать данные, duplex работают как для чтения так и для записи

```
const {Readable} = require('stream');

class MyAwesomeReadStream extends Readable {
  constructor(options) {
    super(options)
    // Initialization
  }

  _read(n) {
    // Reading Logic
  }
}
```

Посмотреть лекцию => https://www.youtube.com/watch?v=o1WPOQgPT3Y
</details>

<details>
<summary>Os - информация об операционной системе и об аппаратном обеспечении компьютера, на котором работает Node.js, только в виде чтения</summary>

```
const os = require('os');

console.log(os.cpus())                  // ? Получаем список нашим процессов
console.log(os.networkInterfaces())     // ? Получаем все network интерфейсы, которые привязаны к текущему адресу
console.log(os.freemem())               // ? Кол-во свободной памяти в системе;
```

</details>

<details>
<summary>HTTP</summary>

Для сетевых запросов мы используем http - модуль который позволяет обрабатывать (как получать так и отправлять) запросы, то есть мы можем создать http сервис, 

```
const http = require('http');
const server  = http.createServer((request, response) => {
  request.end("Hello from Node.js!")
})
server.listen(4000)
```
</details>


<details>
<summary>Timers & related (отложенное исполнения коллбеков)</summary>

1. setTimeout(() => {...}, 500)
2. setInterval(() => {...}, 500)
3. setImmediate(() => {...}, 500) - выполняется всегда после пол.фазы евентлупа, которые забирает новые инпут и отпут события с коллбеками. 
4. process.nextTick(() => {...}, 500) - попадают специальные приоритетные очереди, они выполняются быстрее всего
5. queueMictotask(() => {...}, 500) - она попадает в очередь микротасок, туда же попадают и промисы, которые будут выполняться за nextTick внутри приоритетных очередей

Прочитать - https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick
</details>

</details>
</details>

ыфв