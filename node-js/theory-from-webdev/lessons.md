<details>
<summary>Материалы по каналу web-dev</summary>

<details>
<summary>Уроки 1 - 3 - запуск node, глобальные объекты, импорт и экспорт в node</summary>

Урок №1. Если нужно перейти в определённую папку через терминал и запустить Node.js, то необходимо в начале открыть терминал, написать `cd .\node-js\theory`, что является путем и запустить node написав в терминал команду `node test`. 

---

Урок №2. В node.js существует несколько глобальных объектов: 

* `global` -  аналог window в браузере, представляет глобальное пространство имён. Сюда можно добавлять переменные/функции, которые будут доступны во всём приложении. Но обычно не рекомендуется активно использовать global, так как это может привести к конфликтам имён и ухудшить читаемость кода.
* `__dirname` - возвращает `абсолютный путь к директории` где мы работаем, то есть `..\node-js\theory`;
* `__filename` - возвращает `абсолютный путь к самому файлу`, включая имя и расширение. `..\node-js\theory\test.js`;
* `process` -  предоставляет информацию о процессе Node.js. Позволяет управлять переменными среды, получать аргументы командной строки, завершать процесс и т.д. Примеры: `process.env` – доступ к переменным окружения; `process.argv` – аргументы, переданные через командную строку, `process.exit()` – завершение выполнения скрипта.
* `new URL("..")` - конструктор с помощью которого можно работать с получаемыми серверами, например вытаскивать из url полезные данные

---

Урок №3. Когда нам необходимо с одного файла экспортировать в другой файл. То необходимо в начале объявить, что мы хотим экспортировать через [`module.exports = ...`](./theory/webdev/lesson_03/test.js), если это простая переменная либо через объект значения которые хотим экспортировать, а уже в месте где хотим использовать написать [require()](./theory/webdev/lesson_03/modules.js)

</details>

<details>
<summary>Урок - 4 - чтения, создания и удаления папок/файлов</summary>

1. Для того чтобы прочитать файл, нам необходимо исп метод асинхронной функции  readFile => `readFile(путь до файла, callback срабатывает когда мы вызовем метод)`

2. Для того чтобы написать новый файл мы можем исп метод: `fs.writeFile(путь по которому будет создан новый файл с именем, data - данные, которые будут записаны и коллбек функция)`

3. Если нам необходимо поместить файл в папку или в директорию, нам необходимо исп `mkdir (путь по которому будет создан новый файл с именем и коллбек)`

4. Удаления `файла` через метод `unlink('путь до файла' и коллбек)` и директории (`папки`) через метод `rmdir('путь до папки' и коллбек)`

[Примеры урока](./theory/webdev/lesson_04/app.js)
</details>

<details>
<summary>Урок по 5 - 6 - Создание общего класса EventEmitter и типы потоков</summary>

В node-js есть 4 основных типа потоков - `readable` (читающий), `writable` (пишущий), `duplex`(когда происходит и чтения и запись), `transform` (преобразующий - аналогичный duplex, но позволяет менять читаемая и записываемые данные)

1. Для того чтобы создать `readable` (читающий) поток нам необходимо исп `.createReadStream(путь до чтения файла)`

2. Для того, чтобы создать копию файла или пишущий поток, исп `.createWriteStream(Путь до файла)`
c методом .write()

[Подробнее](./theory/webdev/lesson_06/app.js); 

</details>

<details>
<summary>Уроки по 7 - 11 - Роутинг, установка express и nodemon (автомат перезапуск сервера)</summary>

[В 7 уроке - создавался сервер с помощью http модуля](./theory/webdev/lesson_07-11/app.js), затем добавились [страницы](./theory/webdev/lesson_07-11/views-for-routing) и мы решили с помощью данных страниц прикрутить логику роутинга на сервере с помощью [нативного node.js](./theory/webdev/lesson_07-11/server-node-js-routing.js), а потом произошло установка express и nodemon (автоматический перезапуск сервера) и переписали [нативный node.js на express](./theory/webdev/lesson_07-11/server-express-routing.js) и сравнили их 


</details>

<details>
<summary>Уроки 12 - 13 - EJS - шаблонизатор и работа с ним, а также миддлвары
</summary>

В этом уроке рассматривается ejs-шаблонизатор для того чтобы создать пользовательский интерфейс, а также превратили [статичные html страницы](./theory/webdev/lesson_12-13/views/index.html) в [динамические](./theory/webdev/lesson_12-13/ejs-views/index.ejs), которые будут получать данные от сервера и рендерить их

C помощью шаблонизатор мы можем [вырезать куски кода](./theory/webdev/lesson_12-13/ejs-views/partial/nav.ejs) и использовать их в [разных местах](./theory/webdev/lesson_12-13/ejs-views/index.ejs). Также в теге ejs мы можем описать любой код. Основная задача заключается в том, чтобы на сервере
формировать нужные данные и отправлять их в шаблон. Например есть список [контактов на сервере](./theory/webdev/lesson_12-13/server.js) и нам необходимо [отрисовать](./theory/webdev/lesson_12-13/ejs-views/contacts.ejs)

В контексте node-js - middleware - функция, которая выполняется между получение запроса с серверам и возврата им ответам браузеру. На сервере у нас прямого доступа к динамическим стилям нету, так как они хранятся на сервере, но мы можем написать специальный middleware который дает доступ к [динамическим стилям](./theory/webdev/lesson_12-13/server.js) - app.use(express.static('styles')). А также мы можем использовать посторонние библиотеки, чтобы например узнать сколько занимает загрузка при переходе на другую страницу через `morgan`

```
const morgan = require('morgan') 
app.use(morgan(':method :url :status :res[content-length] - :response-time ms'));
```

Стоит отметить, что middleware должны быть в самом начале. 

</details>

<details>
<summary>Урок 14 - Обработка post-запроса на стороне сервера</summary>

Продолжить просмотр попозже
</details>

