1. Напишите функцию, которая проверяет валидность скобок

```
const checkBrackets = (str) => {
  // Answer
};

console.log(checkBrackets("()[]{}"));     // True
console.log(checkBrackets("((()))"));     // True
console.log(checkBrackets("()[]{]"));     // False
console.log(checkBrackets("valid ()"))    // False
```

---

2. Необходимо написать функцию мемоизации. 

```
const count = (a, b) => {
  return a + b;
};

const memo = (fn) => {
  // Answer
};

const memoized = memo(count)
memoized(4)
```

<details>
<summary> Ответ </summary>

```
const memo = (fn) => {
  const cache = new Map();

  return (...args) => {
    const strArgs = JSON.stringify(args);

    if (cache.has(strArgs)) {
      console.log("c4che");
      return cache.get(strArgs);
    }

    const res = fn(...args);
    cache.set(strArgs, res);
    return res;
  };
};
```

</details>

---

3. Необходимо написать функцию Pipe. Это функция, которая принимает массив функций и вызывает одна за одной

```
const times = (y) = (x) => x * y
const plus = (y) => (x) => x + y
const subtract = (y) => (x) => x - y
const divide = (y) => (x) => x / y

const calculationOne = pipe([times(2), times(3)]);
console.log(calculationOne(2));

const calculationTwo = pipe([times(2), plus(3), times(4)])
console.log(calculationTow(2))

const pipe = (arr) => {
  // Answer
}
```

<details>
<summary>Ответ</summary>
const pipe = (functions) => (input) => functions.reduce((chain, func) => func(chain), input);
</details>

---

4.  Необходимо объяснить что делает данная функция и сделать рефакторинг кода
```
export const attributesLookup = (matchingAttributes, filters) =>
  matchingAttributes.map((item) => {
    const resultChecked =
      filters?.reduce((acc, curr) => {
        if (curr.code === item.code) {
          acc = { ...item, value: curr.value };
        }
        return acc;
      }, {}) ?? {};

    if (Object.keys(resultChecked)?.length === 0) {
      return item;
    } else {
      return resultChecked;
    }
  });

```
```
export const attributesLookup_Refactor = (matchingAttributes, filters) => {
    // Answer
};
```

---

5. Необходимо написать функцию каррирование для сложения чисел

```
function sum(a, b, c) { // Функция суммирования трех чисел
  return a + b + c;
}

function curry(fn) { 
 
}

console.log(curry(sum)(1, 2, 3));    // 6
console.log(curry(sum)(1, 2)(3));    // 6
console.log(curry(sum)(1)(2)(3));    // 6
```

6. Есть массив, в котором есть n кол-во вложенностей в этот массив. Мы не знаем какой уровень вложенностей внутри элемента. Элементов внутри Массива может быть все что угодно: `const arr = [1, 2, ["3", null, 4, ["5", "test", 5, [null, null, 5]]]]`

Необходимо написать функцию которая раскроет все массивы и поднимет все на верхний уровень. Метод flat запрещен, метод concat разрешен

Если решаешь через рекурсию, то если мы не знаем кол-во вложенных элементов внутри, то насколько опасна рекурсия в данном исполнении

```
function flattenArray(arr) {
  const result = [];

  function flatten(element) {
    if (Array.isArray(element)) {
      element.forEach(flatten)
    } else {
      result.push(element)
    }
  }

  flatten(arr);
  return result
}
```

7. Дан многомерный целочисленный массив, необходимо вернуть кол-во целых чисел внутри массива.

```
function getCountNum(arr) {
  let count = 0;

  function countNumber(array) {
    for (let item of array) {
      if (Array.isArray(item)) {
        countNumber(item)
      } else if (Number.isInteger(item)) {
        count++
      }
    }
  }

  countNumber(arr)
  return count
}

console.log(getCountNum([[[]]]));
console.log(getCountNum([0, [1, [5, [4, 3], 1], 1]]));
console.log(getCountNum([[1], 2], 3, 4, [], [5, 3, 0, [6, 7]]));
```

8. Реализуйте функцию deepEqual на JavaScript, которая принимает два параметра и проверяет, являются ли они "глубоко" равными. Входные параметры не могут быть объектами типа Set, Map и их Weak-версиями.

Функция должна учитывать следующие правила:
 - Примитивные типы (числа, строки, булевы значения, null, undefined) сравниваются по значению.
 - Массивы считаются равными, если они имеют одинаковую длину и их элементы попарно равны (в том же порядке).
 - Объекты считаются равными, если они имеют одинаковый набор ключей и значения по этим ключам попарно равны.
 - Функция должна корректно обрабатывать рекурсивные структуры (объекты и массивы, которые содержат ссылки на самих себя).

```
export const deepEqual = (val1, val2) => {};

export const recursive = (object, property) => {
  // Answer
};

export const testData = [
  { value1: 42, value2: 42, expected: true },
  { value1: 'hello', value2: 'hello', expected: true },
  { value1: true, value2: true, expected: true },
  { value1: null, value2: null, expected: true },
  { value1: undefined, value2: undefined, expected: true },
  { value1: null, value2: {}, expected: false },
  { value1: null, value2: undefined, expected: false },
  { value1: { a: 1, b: 2 }, value2: { a: 1, b: 2 }, expected: true },
  { value1: { a: 1, b: 2 }, value2: { b: 2, a: 1 }, expected: true },
  { value1: { a: 1, b: 2 }, value2: { a: 1, b: 3 }, expected: false },
  { value1: [1, 2, 3], value2: [1, 2, 3, 4], expected: false },
  { value1: [1, 2, [3, 4]], value2: [1, 2, [3, 4]], expected: true },
  {
    value1: {
      a: { b: { c: [{ d: 'e', f: [1, 2, '321', null], g: undefined }] } },
      h: [{ i: 'j', k: { l: 'm', n: [null, false, ''] } }],
      o: { p: 'q', r: [1, 2, [3, 4, [5, 6]]] },
      s: { t: [{ u: 'v', w: { x: 'y', z: [true, false, null] } }] }
    },
    value2: {
      a: { b: { c: [{ d: 'e', f: [1, 2, '321', null], g: undefined }] } },
      h: [{ i: 'j', k: { l: 'm', n: [null, false, ''] } }],
      o: { p: 'q', r: [1, 2, [3, 4, [5, 6]]] },
      s: { t: [{ u: 'v', w: { x: 'y', z: [true, false, null] } }] }
    },
    expected: true
  },
  {
    value1: recursive(
      {
        a: { b: { c: [{ d: 'e', f: [1, 2, '321', null], g: undefined }] } },
        h: [{ i: 'j', k: { l: 'm', n: [null, false, ''] } }],
        o: { p: 'q', r: [1, 2, [3, 4, [5, 6]]] },
        s: { t: [{ u: 'v', w: { x: 'y', z: [true, false, null] } }] }
      },
      'self'
    ),
    value2: recursive(
      {
        a: { b: { c: [{ d: 'e', f: [1, 2, '321', null], g: undefined }] } },
        h: [{ i: 'j', k: { l: 'm', n: [null, false, ''] } }],
        o: { p: 'q', r: [1, 2, [3, 4, [5, 6]]] },
        s: { t: [{ u: 'v', w: { x: 'y', z: [true, false, null] } }] }
      },
      'self'
    ),
    expected: true
  },
  {
    value1: recursive(
      {
        a: { b: { c: [{ d: 'e', f: [1, 2, '321', null], g: undefined }] } },
        h: [{ i: 'j', k: { l: 'm', n: [null, false, ''] } }],
        o: { p: 'q', r: [1, 2, [3, 4, [5, 6]]] }
      },
      'self'
    ),
    value2: recursive(
      {
        a: { b: { c: [{ d: 'e', f: [1, 2, '321', null], g: undefined }] } },
        h: [{ i: 'j', k: { l: 'm', n: [null, true, ''] } }],
        o: { p: 'q', r: [1, 2, [3, 4, [5, 6]]] }
      },
      'self'
    ),
    expected: false
  }
];
```
