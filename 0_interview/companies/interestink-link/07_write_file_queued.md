## Write File Queued

```js
// здесь реализовано как IIFE, может быть отдельным модулем, нужно чтобы не было доступа к busy
const writeFile = (() => {
  let busy = false;

  return (...args) => {
    return new Promise((resolve, reject) => {
      if (busy) {
        reject(new Error("busy"));
        return;
      }

      busy = true;

      setTimeout(() => {
        busy = false;
        resolve(...args);
      }, 1000);
    });
  };
})();

////////////////////////////////

const writeFileQueued = (...args) => {
  return writeFile(...args);
};

////////////////////////////////
// тестовые вызовы
console.time("1");
writeFileQueued("foo", "bar").then(() => {
  console.timeEnd("1"); // ~ 1 секунда
});

console.time("2");
writeFileQueued("foo", "baz").then(() => {
  console.timeEnd("2"); // ~ 2 секунды
});

console.time("3");
writeFileQueued("foo").then(() => {
  console.timeEnd("3"); // ~ 3 секунды
});

console.time("4");
writeFileQueued("baz").then(() => {
  console.timeEnd("4"); // ~ 4 секунды
});
```

Задача заключается в реализации функции writeFileQueued, которая должна обеспечить возможность последовательного выполнения асинхронных операций записи в файл без их одновременного выполнения, поскольку параллельная запись в один и тот же файл невозможна

Если не рассматривать извращенные реализации в виде проверки через setTimeout/setInterval/бесконечные циклы, то есть два подхода - объединить промисы в цепочку или сделать очередь

Цепочка промисов это проще и понятнее, но оставляет в памяти последний промис. Хотя если сделать так, чтобы чистилось - как будто ок

Очередь сложнее в реализации, но более масштабируемое решение. И не оставляет ничего лишнего в памяти из коробки (кроме самого массива для очереди)

#### На что здесь обращаем внимание:

- Понимание работы асинхронного программирования/промисов - как самое базовое
- Использует ли кандидат .finally() - то есть допускает ли, что запись в файл может завершиться ошибкой
- Замечает ли кандидат, что writeFile резолвит промис массивом принятых аргументов, возвращает ли то же самое в своей реализованной функции
- В целом на размышления и способность решить такого плана задачу, вряд ли стандартный фронтендер с таким сталкивался
- Будет ли кандидат ориентироваться на какие-то известные ему решения, типа mutex, event loop и тд
- Озвучит ли кандидат оба решения
