<h2 align="center">Основы</h2>

<details>
<summary>Перечислите типы данных в JavaScript? </summary>

В JavaScript существует 8 типов данных, их можно разделить на примитивные и ссылочные. К примитивным относятся: `string; number; bigInt; boolean; symbol (unical id); null и undefined`. А к ссылочному относится `object (объекты)`. 

Функции, массивы также относится к объекту из-за прототипа и прототипного наследования

Если говорить про объекты то они передаются по ссылке, а примитивы по значению

<details>
<summary>Доп.вопрос: В чем разница между null и undefined?</summary>

В том, что `Undefined` - это когда переменная объявлена, но мы ей не присвоено значение, а `null` - когда мы присвоили значение специально, и как бы говорим, что у нас есть переменная и она пустая.

Кстати при нестрогом сравнение undefined и null дает true, а при строгом false, а также при сравнение null == 0 дает false
</details>

<details>
<summary>Доп.вопрос: Как мы можем определить к какому типу данных относится та или иная переменная?</summary>

А определить тип данных можно с помощью typeOf.

Typeof возвращает следующие значения - "undefined", "boolean", "number", "string", "bigint", "symbol", "function", "object"


```js
console.log(typeof 0)                               // * number
console.log(typeof true)                            // * boolean
console.log(typeof 'Javascript')                    // * string
console.log(typeof undefined)                       // * undefined
console.log(typeof Math)                            // * object, так как встроенный глобальный объект
console.log(typeof Symbol('JS'))                    // * symbol
console.log(typeof null)                            // * object
console.log(typeof function() {})                   // * function
console.log(typeof NaN)                             // * number
console.log(typeof typeof 100)                      // * string
```

</details>

<details>
<summary>Доп.вопрос: JavaScript статически, или динамически типизированный язык?</summary>

Динамически типизированный язык, так как происходит автоматическое преобразование типов
</details>

<details>
<summary>Доп.вопрос: Как превратить любой тип данных в булевое и разница между явным и неявным преобразованием?</summary>

В JS мы можем явно преобразовать типы, всего их три: String(), Boolean(), Number() - и все они являются функциями.

Чтобы превратить тип данных в булевый можно использовать:

1. Функцию Boolean(null)
2. !! (Двойное логическое не), `Допилить идею: Если мы применим его к не пустой строке, то оно сначала станет false, а затем true`

Чтобы превратить тип данных в числовое можно использовать:

1. Функцию Number('5')
2. метод parseInt("5")

Что превратить тип данных в строку можно использовать:

1. Функцию String(null)
2. Или через метод Object.prototype.toString(43)

Разница заключается в том, что неявное преобразование происходит автоматически путем арифметических действий, а явное когда мы указываем тип специально через функции Number или ParseInt, функцию String или метод toString, Boolean или двойное логическое !!


```js
console.log(Boolean("0"))             // true
console.log(Number(" 123 "))          // 123
console.log(Number(true))             // 1
console.log(Number(false))            // 0
console.log(Number(' 123z '))         // NaN
```

</details>

<details>
<summary>Доп.вопрос: Перечислите все ложные (falsy) значение? </summary>

Falsy - это следующие значение: "", 0, null, undefined, NaN, false. А все остальное уже true

</details>

<details>
<summary>Доп.вопрос: Что такое NaN?</summary>

NaN (not-a-number) - не является числом. Мы получаем его когда выполняем математическую операцию неправильно. Например, если мы infinity разделим на infinity, то оно нам даст NaN. Для того, чтобы проверить, что число не является числом использует функцию isNaN().
А его особенностью можно выделить то, что она не равна ничему даже самому себе как в строгом, так и в нестрогом сравнении.

</details>
</details>

<details>
<summary> Какие операторы есть в JavaScript? </summary>

`Арифметические операторы`: сложения; вычитания; умножения; делание; возведение в стене `**`; взятия от остатка `%`.

`Операторы сравнения`: > (больше); < (меньше); = (равно); != (не равно), == (нестрогое сравнения) и === (строгое сравнения)

`Логические операторы:`: || (или), && (и), ! (логическое не) 

<details>
<summary>Доп.вопрос: Чем отличается строгое сравнения от нестрогого?</summary>

Нестрогое сравнивает только значения без приведения типов, а строгая сравнивает и значения и типы

</details>

<details>
<summary>Доп.вопрос: Расскажи про логические операторы и их способности?</summary>

К особенностям можно отнести приоритетность, то есть `И` будет выполнятся раньше `Или`, но если мы обернем в скобки то данная приоритетность уже не будет иметь разницы.

- || (Или) - ищет первое истинное значение и возвращает его. А если его не находит, то возвращает последнее значение. У него приоритетность - 5
- && (И) - ищет первое ложное значение и возвращает его. А если оба значения являются истинными, то возвращает последнее. Приоритетность - 6
- ! (Логическое не) - меняет значение на противоположное. Например если строку мы обернет в логическое !'str', то у нас false. Приоритетность - 15
</details>

<details>
<summary>Доп.вопрос: Что такое оператор нулевого слияния ??</summary>

Он возвращает значение правого операнда, если левый операнд содержит null или undefined, в противном случае возвращается значение левого операнда. Он похож на || (Или), так как он возвращает правый операнд если в левом хранится ложное значение, а не только null / undefined
</details>

</details>

<details>
<summary> Расскажите про циклы в JavaScript?</summary>

Циклы нужны для того, чтобы повторить какое-то действие несколько раз. Существует несколько видов циклов: 

1. Классический цикл `for (let i = 0; i > str; i++) {...}` 
2. Цикл через `for in` ==> `for (const name in obj) {...}` служит для перебора объекта и возвращает нам ключи. Если нам необходимо получить значения, внутри цикла нам необходимо в квадратных скобках написать значения. А если мы решим использовать их в массиве, то получим индексы.
3. for ... of - служит для перебора массива и возвращает нам значения.

<details>
<summary> Доп.вопрос: Что такое выражения (expression) и инструкции (statement)</summary>

I. Выражение - это арифметическое действие. Например:`+, -, *, /, %, >, =, ==, i++, --i`, `Math.random - случайное число`.

II. Инструкция - это фрагмент кода, который выполняет определенное действие. К инструкциям относятся: `if, if-else, while, for, for..in, for..of switch, for-in, объявления переменных`
</details>

<details>
<summary> Доп.вопрос: Что такое switch/case и где он используется? </summary>

Switch + case - это по сути аналог if ... else, где выражение switch сравнивается с различными значениями case. 
Внутри каждого case используется break, чтобы выйти из конструкции и избежать выполнения следующих блоков. А
также есть default, который означает что не одно из условий не выполнено

Если говорить про react, то используется он в reducer (redux). И например когда нам нужно именно точное сравнения
</details>

<details>
<summary> Доп.вопрос: Отличие while и do while</summary>

do ... while - должен выполнится хотя бы один раз и не важно верны ли условия или нет, в то время как while может и не выполнится если условия не подходят

`while (условие) { // тело цикла }`
`do { // тело цикла } while (условие);`
</details>


</details>

<details>
<summary>Какие ты знаешь методы у строк JavaScript?</summary>

- `.toUpperCase()` - берет строку и пишет ее с большой буквы (преобразованное в верхний регистр).
- `.toLowerCase()` - берет строку и пишет ее с маленькой буквы (преобразованное в нижний регистр).
- `.split()` - делает из строки массив
- `.trim()` - удаляет пробельные символы с начало и конца строки
- `.startsWith()` проверяют начинается-ли строка с определенного символа который мы укажем внутри
- `.endsWith()` делает противоположное, то есть заканчивается строка c определенным символом
- `.repeat()` - повторяет строку указанное количество раз
- `.includes()` - проверяет, есть ли внутри строки указанная подстрока (часть текста). Возвращает true или false.
- `.replace()` - находит в строке первое совпадение с шаблоном (или строкой) и заменяет его на указанную новую строку.
- `.slice()` - вырезает часть строки и возвращает ее, не меняя оригинал. Можно указать с какого индекса начать и где закончить.

<details>
<summary>Доп.вопрос: Расскажи какие знаешь методы чисел (number) и математические (math) </summary>

#### 1. Number method

- `.toString()` - число преобразовывает в строку
- `.parseInt()` - берет строку и возвращает целое число
- `.isNaN()` - проверяет, является ли значения числа NaN
- `.isFinite()`- проверяет, является ли число конечным;

#### 2. Math method

- `.min(1, 2, 3)` - вернуть минимальное число
- `.max(2, 3, 4)` - вернуть максимальное число
- `.random(1, 2, 3)` - можно получить рандомное число
- `.floor()` - округляет в меньшую степень
- `.ceil()` - округляет в большую степень
- `.pow(2, 3)` - принимает два значения и возвращает возведенную степень `(3, 3) // 27`
- `.abs()` - возвращает абсолютное значение числа. Если это пустые кавычки или пустой массив, то это 0

Ну и другие по типу косинуса, синуса метода
</details>

<details>
<summary>Доп.вопрос: Расскажи какие знаешь методы массива (array)</summary>

`.filter()`
`.map()` 
`.forEach()`
`.sort()` 
`.reduce()` 
`.concat()` - когда есть два разных массива и нам нужна их объединить
`.isArray()` => проверяет является ли значение массивом
`.find()` - вернёт первый найденный в массиве элемент, который подходит под условие.
`.findIndex()` - возвращает уже не найденный элемент, а индекс

Следующие 4 метода меняют исходных массив

`.push()` - добавляет элементы в конец массива и возвращает новую длину массива.
`.pop()` - удаляет из массива последний элемент и возвращает его значение.
`.unshift()` - добавляет элементы в начало массива и возвращают новую длину массива.
`.shift()` - удаляет из массива первый элемент и возвращает его значение.

<details>
<summary>Доп.вопрос: Что будет работать быстрее `pop`, `push` shift и unshift</summary>
</details>

Что будет работать быстрее? => Pop и push - так как их задача лишь добавить или удалить элемент в конце массива, а shift и unshift медленнее так как помимо удаление или добавления первого элемент они будут сдвигать массив вправо или влево.
</details>

<details>
<summary>Доп.вопрос: Что ты можешь рассказать о методах .splice(), .slice()</summary>

`.splice()` - меняет исходный массив, добавив либо удалив по индексу данные

`.slice()` - возвращает новый массив, содержащий какую-то определенную часть исходного массива. Например когда нам надо вернуть не весь массив, а только первые 2 элемента
</details>


<details>
<summary>Доп.вопрос: Какие методы мутируют и не мутирует исходный массив?</summary>

Мутирует - .sort, .reverse, .push. .pop, .shift, unshift, .splice

Не мутируют - map, filter, slice, concat,
</details>

</details>

<details>
<summary>Расскажите про объект?</summary>

Объект в JavaScript — это тип данных, который используется для хранения коллекций значений в виде пары ключ: значение. Ключи — это обычно строки (или символы), а значения могут быть любыми типами данных, включая другие объекты. И объекты никогда не равны друг другу, так как имеет ссылочный тип данных.

<details>
<summary>Доп.вопрос: какая разница между объектом и массивом</summary>

- У массивов есть методы тех, которых нет у объекта, также и наоборот
- Чтобы обратится к какому-то элементу в массиве мы должны использовать индекс от нуля. А у объекта обращение идет через точку
- Также у массива есть свойство length - делает подсчет всех элементов внутри массива.
</details>

<details>
<summary>Доп.вопрос: как мы можем определить наличие св-в в объекте</summary>

- `hasOwnProperty()` - проверяет наличие свойств только в самом объекте
- `in` - проверяет наличие свойств как в самом объекте, так и в прототипах
- Обратится к объекты напрямую с помощью индексовой нотации: `console.log(obj['prop1']); => foo`

```js
let value = {
  prop1: "foo",
  prop2: "bar",
};

console.log(obj.hasOwnProperty("prop1"))        // True
console.log(obj.hasOwnProperty("prop3"))        // False
console.log("prop1" in obj)                     // True
console.log("prop3" in obj)                     // False
console.log(obj["prop1"])                       // foo
console.log(obj["prop3"])                       // undefined
```

</details>


<details>
<summary> Доп.вопрос: В чем отличие методов объекта: key(), values(), entries(), fromEntries() </summary>

1. `Object.keys()` - возвращает массив ключей
2. `Object.values()` - возвращает массив значений
3. `Object.entries()` - возвращает массив ключей и массив значения
4. `Object.fromEntries()` - он преобразует список пар: ключ и значение в объект

```
let user = {
  name: "John",
  age: 30,
}

Object.keys(user);          // ["name", "age"]
Object.values(user);        // ["John, 30]
Object.entries(user);       // _0: (2) ['name', 'John']; _1: (2) ['age', 30]
```

```js
let user = [
  [0, 2],
  [1, 3],
  ["vulgar", true],
]
console.log(Object.fromEntries(user))       // {0: 2, 1: 3, vulgar: true}
```

</details>
</details>

<details>
<summary> Для чего нужен строгий режим в JavaScript?</summary>

Строгий режим помогает писать более безопасный код, и помогает находить потенциальные ошибки 

- Например мы обратились к переменной, но самой переменной нету. 
- Говорит о том, что нельзя дублировать параметры внутри функции - `function(a, a, b)`
- Например по умолчанию this ссылается на window, а при строгом режиме вернет undefined

</details>

<details>
<summary>Какие существуют типы всплывающих окон и типы ошибок в JavaScript?</summary>

Типы всплывающих окон: 

`alert` - выводить информацию во всплывающем окне;

`confirm` - спрашивать соглашение во всплывающем окне; подтвердить по ОК или Отмену

`prompt` - всплывающем окно, где просят написать что-то в инпут поле

Типы ошибок: 

`SyntaxError` - синтаксическая ошибка возникает когда мы написали неправильно какое-то слово: return

`ReferenceError` - возникает когда js не может найти какую-то ссылку в которой мы пытаемся получить доступ. Например хотим определенную переменную найти а его нет

`TypeError` - ошибка в типе - например у нас есть переменная, а мы к нему обращаемся через объект или пытаемся вызвать его.
</details>
</details>

<h2 align="center">Переменные и функции</h2>

<details>
<summary> Разница между переменными: var, let и const?</summary>

1. `Let` и `const` появились в ES6, а `var` был еще до него;
2. `Let` и `const` имеют блочную область видимости, а var - глобальную (или локальную);
3. `Let` мы можем присвоить новое значение, однако не можем создать переменную с тем же именем, у `const` мы не можем присвоить новое значение. У `var` мы можем как присвоить новое значение, так и повторно объявить. Раньше чтобы решить проблему области видимости у `var` люди оборачивали в так называемые анонимные самовызывающиеся функции;
4. Есть такое понятие как временная мертва зона (temporal dead zone), что означает мы не можем вызвать переменная до его инициализации, и она появилась с let и const. Если мы попытаемся вызвать их то получаем ошибку, однако в случае с var у нас просто выведется undefined, это связано с всплытием. 
5. Var сплывает, а let и const нет

<details>
<summary>Доп.вопрос: А что если мы не объявили переменную?</summary>

`Необъявленная переменная` - это когда мы написали какое-то значение `a = 20` без переменных var, let либо const. Область видимости у необъявленных переменных - глобальная, что означает, что они доступны из любого места кода, что не очень хорошая практика как и var. Если мы будем использовать строгий режим, то получим ошибку ReferenceError, а в нестрогом undefined
</details>

<details>
<summary>Доп.вопрос: А какие есть правила задавания имен переменных и функций</summary>

Если мы говорим задание имен переменных, то

1. Они должны содержать буквы на латинице, он должен отражать смысл того, что он хранит: `let age = 20`;

2. Цифр: `let user2 = 'Antony';`

3. Символы доллара: `let $user = 'Alice';`

4. Нижнего подчеркивания: `let _user = 'Pete';`

Если мы говорим то, что как не стоит начинать, то - первый символ не должен быть цифрой: `let 10user = 'Nick';`

Имя функции должно понятно и четко отражать что она делает и что возвращает. Функция - это действия по этому её имя
обычно является глаголом: `function checkValue() {}`
</details>
</details>

<details>
<summary>Расскажите про область видимости (scope)?</summary>

`Глобальная область видимости` - это когда мы объявляем переменную внутри самого файла js (внутри скрипта) не оборачивая ни функцией, циклом. Они доступны из любого места в коде.

`Функциональная область видимости` - переменные объявленные внутри функций

`Блочная область видимости` - это когда переменная доступна только внутри блока, за пределами блока она не доступна.

</details>

<details>
<summary> Разница между function declaration и function expression? </summary>

Выделяют два способа объявлении функции:
1. Через ключевое слово: function =>  `function multyple() {...}` 
2. Через переменную `let multiply = function () {...}`

Ключевое отличие: Function declaration можно вызывать до объявления благодаря всплытию (hoisting), а function expression — нет.

Подробнее: 

Отличие заключается в том, что к function declaration можно вызвать до того как объявить. Так как JS собирает все строчки где объявляется function, а также через Hoisting (поднимает) их самый вверх, что позволяет нам сначала вызвать их, а потом объявить. Еще наверное стоит отметить, что если мы объявим function expression через переменную var, то и она будет всплывать

<details>
<summary> Доп.вопрос: Как передаются параметры в функцию: по ссылке или по значению?</summary>

Когда мы передаем значения в функцию, то создается копия этого значение, в то время как объект передает ссылку на участок памяти где был вызван объект

```js
var n = 1;

function f(n) {
  n = 3;
}
f(n)
console.log(n)     // 1
```

```js
var obj = { a: 1 };

function f1(o) {
  o.a = 5;
}

f1(obj)
console.log(obj)  // { a: 5 } 

// Во второй случае передается уже ссылка на объект. По этому ответ 5
```
</details>

<details>
<summary> Доп.вопрос: Разница между параметром и аргументом функции? </summary>

Когда мы пишем функцию и внутри обычных скобок указываем a, b: `function value (a, b) {...}`, то это параметры.
После того как мы передали параметры мы пишем код например `return a + b`. После вызываем этой функцию через запятую,
так вот значения, которые передаются при вызове функции называются аргументами: foo (5, 7).

</details>
</details>

<details>
<summary>Что такое всплытие (Hoisting)?</summary>

`Всплытие` — это механизм в JavaScript, при котором объявления переменных (var) и функций (function declaration) "поднимаются" в начало своей области видимости, что позволяет использовать их до фактического объявления в коде.
</details>

<details>
<summary> Что такое замыкание (Closure)? </summary>

`Замыкание` - это функция вместе со своим лексическим окружением. Когда внутри этой функции мы обращаемся к переменной, которой нету в нашем лексическом окружении, то он идет вверх пока не найдет эту переменную, в худшем случае ошибка при включенном 'use strict'
</details>

<details>
<summary> Разница между обычными функциями и стрелочными? </summary>

1. Синтаксис;
2. Обычные функции всплывают, а стрелочные нет, если конечно они не объявлены через var;
3. У обычных функций this динамический и зависит от того где была вызвана, в то время как у стрелочных нет своего this и берет он из лексического окружении функции откуда была вызвана;
4. В обычных функция можно использовать arguments, а у стрелочных нет аргумента - `вместо этого можно использовать spread-оператор`
5. Обычные функции могут быть вызваны с конструктором new, а стрелочные нет. Если мы попытаемся использовать стрелочную функцию как конструктор, то получим ошибку
</details>

<details>
<summary>Что такое this (контекст) и для чего нужен .call(), .apply() и bind()?</summary>

This - специальное ключевое слово в JavaScript, которое указывает на контекст, и он является динамическим. В зависимости от того, где мы его вызываем, на то он и будет ссылаться. Например, если мы вызовем его глобально, в браузере или внутри обычной функции не используя 'use strict', то ссылка будет указывать на объект window, а с использованием вернет ошибку. Если как метод объекта будет ссылается на этот объект

---

Методы .call(), .apply() и bind() используются для управления значением this, отличие в том, что:

`.call()` и `.apply()` - вызываются сразу, а `.bind()` - привязывает к контексту и вызывается позже, и если `.bind` у нас много, то сработает только первый. 
Также стоит отметить, что аргументы у `.call(obj, '', '')` указываются через запятую, а у `.apply(obj, ['', ''])` в виде массива

```js
const person1 = { name: 'Алиса', age: 25 };
const person2 = { name: 'Боб', age: 30 };

function introduce(greeting, punctuation) {
  console.log(`${greeting}, меня зовут ${this.name}${punctuation}`);
}

introduce.call(person1, 'Привет', '!');             // "Привет, меня зовут Алиса!"
introduce.apply(person1, ['Привет', '!']);          // "Привет, меня зовут Алиса!"
introduce.call(person2, 'Здравствуйте', '.');       // "Здравствуйте, меня зовут Боб."
introduce.apply(person2, ['Добрый день', '...']);   // "Добрый день, меня зовут Боб..."

const introduceAlice = introduce.bind(person1);
const introduceBob = introduce.bind(person2);
// Теперь можем вызывать их когда угодно
introduceAlice('Хай', '!');                         // "Хай, меня зовут Алиса!"
introduceBob('Привет', '.');                        // "Привет, меня зовут Боб."
```

</details>

<details>
<summary> Что такое чистая функция? (Pure Function) </summary>

Чистая функция - это та функция, у которой нет побочных эффектов. К побочным эффектом относится: `Запросы на сервер`, `Изменения входных параметров`, `Обращение к дому (query selector), если говорим про JS.`

А также всегда возвращает один и тот же результат для одних и тех же аргументов.

Плюсы чистых функций:

- Уменьшает кол-во багов (так как он максимально низко влияет на остальную систему. Если я знаю, что у меня есть баг в функции, то он внутри него)
- Легче тестировать
- Легче понимать, поскольку все что она делает заключено внутри нее и не нужно никуда бегать.
</details>

<details>
<summary> Что такое функция генератор?</summary>

Генераторы — это функции, которые могут приостанавливать своё выполнение и возвращает значение через yield и возобновлять его позже через next().

У next кстати два состояние value и done, если он не конечный, то done: false, а если завершен то done: true

```js
function* generatorFunction() {
  yield 'Первое значение';
  yield 'Второе значение';
  return 'Финал';
}

const gen = generatorFunction();

console.log(gen.next()); // { value: 'Первое значение', done: false }
console.log(gen.next()); // { value: 'Второе значение', done: false }
console.log(gen.next()); // { value: 'Финал', done: true }
```

</details>

<details>
<summary>* Разница между синхронными и асинхронными функциями?</summary>

Синхронные функции являются блокирующими, а асинхронные нет. Когда интерпретатор натыкается на синхронную функцию, он блокирует дальнейшее выполнения операции прежде чем данная функция будет выполнения. По этому набор таких функций выполняется последовательно - одна за другой. Асинхронные функции наоборот не блокирует дальнейшие выполнения скрипта. По этой причине различные тяжелые операции по типу запроса данных делают асинхронными. Обычно такие функции в качестве аргумента принимают callback - это еще одна функции, которая выполнится как только будет выполнено асинхронная функция и которая сможет обработать полученный результат

</details>

<details>
<summary>* Типы функций по способности принимать другие функции? </summary>

В JS можно выделить 3 основные типов функций в зависимости от принимаемых данных:

- Функция первого класса (first-class functions) – это функция, которая не принимает другую функцию в качестве аргумента и не возвращает функцию как значения

`const firstOrder = () => console.log( “Hello”)`

- Функции высшего порядка (HOF) – это функция, которая принимает другую функцию в качестве аргумента или возвращает функцию как значение

`const higherOrder = firstOrderReturn => firstOrderReturn()`

- Унарная функция – это функция, которая принимает только 1 аргумент, который не является функцией.

`const unaryFunction = (a) => console.log(${a} + world!)`

</details>

<details>
<summary>* Что такое мемоизация? Реализуйте базовую логику функции для мемоизации? </summary>

Это прием создании функции способность запомнить ранее вычисленное значение, а также результат. В результате при повторном вызове функции с одинаковыми аргументами она не будет выполнена, а результат работы вернется из кеша.

В программировании мемоизация — это метод оптимизации , который делает приложения более эффективными и, следовательно, более быстрыми. Он делает это, сохраняя результаты вычислений в кеше и извлекая ту же информацию из кеша в следующий раз, когда она потребуется, вместо того, чтобы вычислять ее снова.

</details>

<details>
<summary>* Что такое функции высшего порядка (Higher Order Functions)?</summary>

HOF - обычная функция, которая принимает в качестве аргумента другую функцию, добавляет в эту функцию так скажем новый функционал и возвращает его - это map, filter, reduce

<img src="./assets/3.PNG" alt="Primer">

</details>
</details>

<h2 align="center">Асинхронный код</h2>

<details>
<summary>Что такое callback-функцию?</summary>

Callback — это функция, которая передаётся в другую функцию в качестве аргумента. Это один из способов работы с асинхронным кодом. Однако существует проблема, называемая Callback hell («ад колбэков»), когда внутри одного колбэка находится другой колбэк, внутри него — ещё один, и так далее. Такой код становится очень сложно читать, тестировать и поддерживать. Поэтому в ES6 появились Promise (промисы), а в ES8 — async/await

</details>

<details>
<summary>Что такое Promise и какие у него есть методы?</summary>

Это один из способов работы с асинхронным кодом и пришел на замену callback. Promise представляет из себя специальный объект и у него есть три состояния: `pending`, `fulfilled`, `rejected`.

--- 

Также можно вспомнить, что у промисов есть методы в отличии от callback. К методом промисов относится:
- `.all()` - дожидается выполнения ВСЕХ promises, если успешно вернет массив, если нет, то вернет последний promise с ошибкой
- `.allSettled()` - дожидается выполнения ВСЕХ promise, и не важно выполнятся они успешно или нет он вернет массив полученных значение (ответов)
- `.any()` - дожидается выполнения ПЕРВОГО УСПЕШНОГО promise и возвращает результат, если не находит возвращает ошибку
- `.race()`дожидается выполнения ПЕРВОГО promise и возвращает результат.

А также значительно легче читать промисы

<details>
<summary>Например есть promise и мы вызываем какую-то функцию которая возвращает promise. Мы на него подписались через .then, .catch и т.д. Теперь вопрос а может ли быть ситуация когда promise никогда не закончится не then, не catch не вызовутся? Нам нужно чтобы оно было бесконечное как это сделать</summary>

```
const neverEndingPromise = new Promise((resolve, reject) => {
  // ничего не делаем
});
```
</details>

<details>
<summary> Есть ли у promise какой-то функционал, что если через 5 секунд он ничего не сделал, то как принудительно зарезолвились или заречеджектились promise</summary>

Promise.race c SetTimeOut

```
function withTimeout(promise, timeout) {
    return Promise.race([
        promise,
        new Promise((_, reject) =>
            setTimeout(() => reject(new Error('Timeout exceeded')), timeout)
        )
    ]);
}

// Использование
const somePromise = new Promise((resolve) => {
    // Симуляция долгой операции
    setTimeout(() => resolve('Done!'), 10000); // завершится через 10 секунд
});

withTimeout(somePromise, 5000) // Таймаут 5 секунд
    .then(result => console.log(result))
    .catch(error => console.error(error.message));
```
</details>
</details>

<details>
<summary>Что такое async/await? И что у него общего у promise </summary>

Async является еще одним способом написание асинхронного кода, который всегда возвращает promise, await добавляется в тело функции и ждет выполнения promise. 

Если какой-то из await не выполнится, то дальше он не пойдет и поместится в catch, а это обработчиком ошибок

```js
async function getMainActorProfileFromMovie(id) {
  try {
    const movieResponse = await fetch(`https://swapi.dev/api/films/${id}/`);
    const movie = await movieResponse.json();
    return characterResponse.json();
  } catch (err) {
    console.error('Произошла ошибка!', err);
  }
}
```
</details>

<details>
<summary>Что такое Eventloop (цикл событий) и как он работает?</summary

Eventloop - это бесконечный цикл, который решает проблему однопоточности. У него есть callstack (стек вызовов), куда постоянно попадает задачи, он их выполняет и ждет снова поступления новых задачи. Задачи в свою очередь делятся на микро и макро-таски. У микро-тасок приоритетность больше и они будут выполняться раньше чем макро-таски. К микротаскам можно отнести then, catch, finally у промисов, queueMicrotask, MutationObserver, async await а к макро таском setTimeOut, setTimeInterval, события
</details>

<details>
<summary>Задачи по evenloop и вывода консоль</summary>

<details>
<summary>Если все micro-task выполнятся а дальше пойдут macro-task внутри которого есть micro-task , что вызовется микро или макро</summary>

Сначала выполнится внутри micro-task , а затем уже macro-task
</details>

<details>
<summary>Каков будет ответ</summary>

```js
new Promise((resolve, reject) => {
    resolve(1);
    resolve(2);
    reject('error')
}).then(
    (value) => console.log(value),
    (error) => console.log('error')
)
```
---

Промис вызовется один раз и ответ будет зарезволенный 1, а последующие будут игнорировать, по этому и ответ 1
</details>


<details>
<summary>Каков будет ответ</summary>

```js
Promise.reject('a')
    .catch((p) => p + 'b')
    .catch((p) => p + 'c')
    .then((p) => p + 'd')
    .then((p) => console.log(p))

console.log('f')
```

---

В начале получаем зареджектный а, потом мы ловим catch и будет 'ab', следующий catch пропуск так как мы уже обработали ошибку, затем идем в then и выводим 'abd'
</details>

<details>
<summary>Опиши подробно последовательность ответа</summary>

```js
Promise.resolve(1)
  .then((x) => x + 1)
  .then((x) => { throw x } )
  .then((x) => console.log(x))
  .catch((err) => console.log(err))
  .then(x => Promise.resolve(x))
  .catch((err) => console.log(err))
  .then((x) => console.log(x))
```

---

Есть зарезвлоенный промис 1, мы идем к then получаем 2, затем выбрасываем ошибку после чего следующий then пропускаем и в блоке catch на пятой строчке мы как раз выводим и нашу двойку потому что мы ранее выбрасили двойку. После блока catch ошибка у нас считается обработанной по этому мы идем выполнения then. В следующем then у нас в качестве x ничего не передается и значит результат равен undefined. Блок catch пропускаем так как ошибок у нас нет и на последней строчке мы этот undefined выводим в консоль


</details>

<details>
<summary>Level №1 - Простой порядок</summary>

```js
console.log('1');
setTimeout(() => console.log('2'), 0);
Promise.resolve().then(() => console.log('3'););
console.log('4');
```

--- 

Ответ: 1432 

Решение: 1 и 4 попадут в стек сразу выполнятся так как они синхронные, 3 попадает в микротаски и выполнится сразу, а 2 идет к макротаскам и он выполнится последним
</details>

<details>
<summary>Level №2 - Микрозадачи vs макрозадачи</summary>

```js
setTimeout(() => console.log('timeout'));
Promise.resolve().then(() => console.log('promise'));
queueMicrotask(() => console.log('microtask'));
console.log('code');
```

--- 

Ответ: code → promise → microtask → timeout

Решение: code выполнится сразу, затем идет две микрозадачи в очередь - promise и microtask, и выполнятся в начале все они, а затем уже timeout который в макрозадачи

</details>


<details>
<summary>Level №3</summary>

```js
Promise.resolve()
  .then(() => {
    console.log('promise1');
    Promise.resolve()
      .then(() => console.log('promise2'));
  })
  .then(() => console.log('promise3'));

console.log('code');
```

--- 

Ответ: code → promise1 → promise2 → promise3

Вначале выполнится code, затем в callstack будут записан then и внутри него создастя еще одна микрозадача с promise2, пока все микрозадачи первого зена не завершится он не перейлет к следующему then с промис3

все внутренности первого зена включая промиса, а затем уже второй then отработает

</details>

<details>
<summary>Level №4</summary>

```js
console.log(1);                       
setTimeout(() => console.log(2));
Promise.resolve().then(() => console.log(3));
Promise.resolve().then(() => setTimeout(() => console.log(4)));
Promise.resolve(console.log(5)).then(() => console.log(6));
setTimeout(() => console.log(7));
console.log(8);                       
```

--- 

Ответ: 1 -> 5 -> 8 -> 3 -> 6 -> 2 -> 7 -> 4

Решение: в начале выполнится 1 в console.log, затем 5 хоть она и в промисе, но аргумент из Promise.resolve() вычисляется синхронно, и чтобы быть в микрозадачи нужно быть в .then, .catch, затем синхронный код 8, а теперь разбираем все микрозадачи это 3 и 6, 4 уходит в макрозадачу. И у нас остается 3 макрозадачи - setTimeout 2, 7, 4. А в самом конце 4, потому что он попал в очередь макротаск после того как там уже было 2 и 7 и он добавился в конец

</details>

<details>
<summary>Level №5</summary>

```js
setTimeout(function timeout() {
  console.log("Таймаут");
}, 0);

let p = new Promise(function (resolve, reject) {
  console.log("Создание промиса");
  resolve();
});

p.then(function () {
  console.log("Обработка промиса");
});

console.log("Конец скрипта");
```

---

Ответ: Конец скрипта -> Создание промиса -> Обработка промиса -> Таймаут

Решение => у нас then., .catch, .finally - ассинхронны, а простой вызов промиса синхронный по этому в начале у нас выполнится синхронные операции - это создание промиса, конец скрипта, обработка промиса (микротаска) и Таймаут (макротаска)

</details>


<details>
<summary>Level №6</summary>

```js
const promise = new Promise((resolve) => {
  console.log(1);

  setTimeout(() => {
    console.log("timerStart");

    resolve("success");

    console.log("timerEnd");
  });

  console.log(2);
});

promise.then((res) => console.log(res));

console.log(4);
```

---

Ответ: 1 -> 2 -> 4 -> timerStart -> timerEnd -> success

Решение:
- Сначала выполняются все синхронные операции (console.log(1), console.log(2), console.log(4)).
- Затем срабатывает setTimeout, выполняя console.log("timerStart"), затем resolve("success"), затем console.log("timerEnd").
- После завершения макрозадачи setTimeout, обрабатывается микрозадача promise.then(), которая выводит "success".

</details>


<details>
<summary>Level №7</summary>

```js
console.log(1); // вывод синхронный

setTimeout(function timeout() {
  console.log("Таймаут");
}, 0);

new Promise(function (resolve, reject) {
  console.log("Promise");    // вывод синхронный
  setTimeout(() => {
    console.log(777);
    resolve();
  }, 0);
})
  .then(() => console.log("then1"))
  .then(() => console.log("then2"));

console.log(4);   // вывод синхронный

setTimeout(() => {
  console.log("timeOut2");
}, 0);
```

Решение:

- В начале выполняем все синхронны операции это 1, затем settimeout идет в макротаски. Внутри конструктора есть промис это синхронная операция Promise вывелся, и следующий setTimeout идет к макротаском, then1 и then2 пропускается так в начале должен выполнится setTimeout в макротаске. Выводим затем 4 он тоже синхронный и у нас остается последняя макротаска - timeout2. Теперь разберем макротаски - выводим первый таймаут, затем внутри сработывает второй таймаут выводится 777 и промис резолвится и срабатывают then1 и then2 в конце срабатывает последний макротаск timeout2
</details>

<details>
<summary>Level №8</summary>

```js
setTimeout(console.log(1));

new Promise(function (resolve, reject) {
  resolve();
})
  .then(() => console.log(2))
  .then(() => console.log(3))
  .catch(() => console.log("err"))
  .then(() => setTimeout(() => console.log(4)));

console.log(5);
```

Ответ: 1 => 5 => 2 => 3 => 4

Решение: setTimeout(console.log(1)) получает результат выполнения сразу, а это означает что он синхронный, дальше промис зарезовленный и мы получаем 2, 3, catch пропускаем и получаем 4 который берем из макротаски 

</details>


<details>
<summary>Level №9</summary>

```js
console.log("A");

const p = new Promise((resolve) => {
  resolve("");
  console.log("B");
});

p.then(() => {
  p.then(() => console.log("C"));
  console.log("D");
});

setTimeout(() => {
  console.log("E");
}, 0);

p.then(() => console.log("F"));
```

---

Ответ: А => B => D => F => С => E 

Решение => 
  A (синхронный код), B (синхронный код),
  первый then (внутри него: выводит D и создает новую задачу C в конец очереди),
  затем выполняется F (который уже был в очереди перед C),
  затем выполняется C (добавленный позже),
  затем макрозадача E.
</details>

<details>
<summary>Level №10</summary>

```js
setInterval(() => console.log(1), 1)
setTimeout(() => console.log(2), 1)
console.log(3);
Promise.resolve().then(() => console.log(4));
const promiseTest = new Promise(() => {
  console.log(5)
})
setTimeout(() => console.log(6), 0)
console.log(7)
promiseTest.then(() => console.log(8))
```

---
Ответ: 3 => 5 => 7 => 4 => 6 => 2 => 1111111

Решение:
1. => 357 - синхронные операции
2. => 4 - микротаска, 8 пропускаем так как нет resolve
3. => 6 и 2 выполняются по очереди в микросекундах
4. => setInterval до самого конца идет 1 1 1 1

</details>

<details>
<summary>Level №11</summary>

```js
setTimeout(() => console.log("setTimeout 1"), 0);

new Promise((resolve, reject) => {
  console.log("Promise 1");
  resolve();
  console.log("Promise 2");
}).then(() => console.log("Promise 3"));

Promise.resolve().then(() => setTimeout(() => console.log("setTimeout 2"), 0));

Promise.resolve().then(() => console.log("Promise 4"));

setTimeout(() => console.log("setTimeout 3"), 0);

console.log("final");
```

---

Ответ: Promise1, Promise2, final, Promise3, Promise4, setTimeout1, setTimeout2, setTimeout3


</details>

<details>
<summary>Level №12</summary>

```js
console.log(1)

setTimeout(() => {
  console.log(2)
})

Promise.resolve().then(() => {
  console.log(3)
})

console.log(4);

setTimeout(() => {
  console.log(5)
}, 0)

console.log(6);

const fool = () => {
  console.log('foo1');
  return Promise.resolve().then(fool)
}

fool();
```

---

Ответ: 146 => foo1 => 3 => fool бесконечно и микрозадача никогда пустой не станет
</details>


<details>
<summary>Level №13</summary>

```js

async function f() {
  console.log(1);
  const promise = new Promise((resolve) => {
    console.log(2);
    setTimeout(() => {
      console.log(3);
      resolve('готово!')
      console.log(4)
    })
  })

  console.log(5);

  const result = await promise;
  console.log(6)
  console.log(result)
  return 'Result'
}

f();
console.log(7);
```

--- 

Ответ: 1 => 2 => 5 => 6 => 7 => 3 => 4 => ГОТОВО

Объяснения, в начале у нас срабатывает до await код - это 1 2 5 потом выходит из функции и срабатывает 7 заходит обратно и мы должны выполнить все операции промиса так 3 4 6 'готово'

</details>



<details>
<summary>Level №14</summary>

```js
function checkOrder() {
    console.log('1');

    async function asyncFn() {
      console.log('2');
      await Promise.resolve(null);
      console.log('3')
    }

    asyncFn();

    new Promise((resolve) => {
      setTimeout(() => {
        resolve();
        console.log('4')
      }, 0);
      
      console.log('5')
    }).then(() => console.log('6'))

    console.log('7')
}
console.log('8');
checkOrder();
console.log('9')

```

--- На

Ответ: 8 => 1 => 2 => 5 => 7 => 9 => 3 => 4 => 6
</details>

<details>
<summary>Level №15</summary>

```js
console.log('1')
setTimeout(() => console.log('2'), 0)

async function asyncFunc() {
  console.log('3')

  await new Promise((resolve) => {
    console.log('4');
    setTimeout(() => {
      console.log('5');
      resolve()
    }, 0)
  })
  
  console.log('6')

  Promise.resolve()
    .then(() => console.log('7'))
    .then(() => console.log('8'))
}

asyncFunc();
console.log('9')
```

Ответ: 1 => 3 => 4 => 9 => 2 => 5 => 6 => 7 => 8

</details>

<details>
<summary>Level №15</summary>

```js
setTimeout(() => console.log('timeout'));
Promise.resolve().then(() => Promise.reject('reject').catch(console.log));
window.requestIdleCallback(() => console.log('requestIdleCallback'));
window.requestAnimationFrame(() => console.log('requestAnimationFrame'));
console.log('code')
```

Ответ: `code` (синхронный код) => `reject` (микротаска) => requestAnimationFrame(сработает перед полной загрузкой страницы хоть и тоже макротаска) => timeout => requestIdleCallback(уже после завершение страниц)

</details>
</details>

<details>
<summary>Какие типы таймеров есть в JavaScript?</summary>

В JS есть два основных типа таймеров:

- `setTimeout(...)` - позволяет вызвать переданную функцию один раз через определенное время
- `setInterval(...)` - позволяет вызвать переданную функцию много раз через определенный интервал времени. Чтобы отменить `setInterval` мы можем использовать тип: `clearInterval()` и внутрь передаем переменную, где использовали `setInterval`.

</details>

<h2 align="center">Прототип, прототипное наследование</h2>

<details>
<summary>Что такое прототип в JS? И как работает цепочка прототипов</summary>

У каждого объекта в JavaScript есть прототип — это специальная ссылка на другой объект (или null). Прототип содержит свойства и методы, к которым объект может обратиться через прототипное наследование.

В коде мы можем получить к ней доступ через геттер/сеттер Object.getPrototypeOf(obj) / Object.setPrototypeOf(obj, proto) или через устаревшее свойство __proto__.

Как это работает:

Когда мы обращаемся к свойству объекта, JavaScript сначала ищет его в самом объекте. Если не находит — переходит по ссылке в прототип и ищет там. Затем — в прототипе прототипа, и так далее, пока цепочка не закончится на null (это значит, что свойство не найдено).

- Что произойдет если запрашиваемая св-в не найдено в объекте? - Вернет undefined
</details>

<details>
<summary>В чём разница между __proto__ и prototype?</summary>

У функций есть свойство prototype, которое становится прототипом (__proto__) для объектов, созданных через new этой функции, а __proto__ - ссылка на прототип у любого объекта.

</details>

<h2 align="center">DOM-дерево</h2>

<details>
<summary>Что такое DOM (document object model) ?</summary>

DOM (Document Object Model) — это специальная древовидная структура, которая позволяет управлять HTML-разметкой из JavaScript-кода. Управление обычно состоит из добавления и удаления элементов, изменения их стилей и содержимого.

<details>
<summary>Доп.вопрос: какие ты знаешь методы поиска элементов в DOM?</summary>

`document.getElementById('id')` - поиск по Id, если он есть;

`querySelector('class')` - возвращает первые найденный элемент по классу;

`querySelectorAll('class')` - возвращает все элементы, который подходят классу

Есть также другие способы (они более старые)

`elem.getElementsByTagName(tag)` поиск по тегу;

`elem.getElementsByClassName(className)` поиск по имени класса;
</details>
</details>

<details>
<summary>Что такое распространение события (Event Propagation)?</summary>

Дополнить ....
</details>

<details>
<summary>Что такое делегирование событий (Event Delegation)?</summary>

Дополнить ....
</details>

<details>
<summary>Что такое всплытие и погружение?</summary>

Всплытие событие 

<details>
<summary>Доп.вопрос: что делает event.preventDefault()</summary>

</details>

<details>
<summary>Доп.вопрос: что делает event.stopPropagation()</summary>

...
</details>

<details>
<summary>Доп.вопрос: что делает event.stopImmediatePropagation()</summary>

...
</details>

<details>
<summary>Разница между e.preventDefault() и e.stopPropagation() и e.stopImmediatePropagation()?</summary>

</details>

</details>

<details>
<summary>Разница между event.target и event.currentTarget?</summary>

Переделать ....

`event.target` - элемент на котором произошло событие
`event.currentTarget` - элемент на котором висит обработчик.
</details>

<details>
<summary>Виды (обработчик) событий в JavaScript?</summary>

Есть несколько видов событий: 

1. Событие по мыши - `click` (клик мышки), `dblclick` (двойной клик), `mouseover` (навели на элемент), mouseout (увели от элемента мышь)

2. События клавиатуру - `keydown` и `keyup` - когда клавиша нажата и опущена

3. События формы - `change` (изменения значения), `focus`, `blur`, `submit`

<details>
<summary>Доп.вопрос: Для чего используется метод .focus() и blur()?</summary>

Например когда у нас загрузилась страница, то с помощью метода `focus()` мы можем сразу же попросить пользователя ввести необходимые данные. Ему не нужна будет кликать на определенный input. Метод focus() устанавливает focus на элемент

`.blur()` - снимает фокус с элемента. Например когда мы отправили форму либо кликнули за пределами input поля
</details>

<details>
<summary>Доп.вопрос: Как называется события которое свидетельствует о том, что наш дом полностью загружен?</summary>

domContentLoaded
</details>

</details>

<details>
<summary>Для чего используется свойство window.navigator?</summary>

Необходим для получения информации о браузере и его среде исполнения

`navigator.userAgent` - информацию о браузере и операционной системе
`navigator.language` – основной язык браузера (например, "ru-RU").
`navigator.languages` – массив предпочтительных языков.
`navigator.geolocation` – доступ к геолокации.
`navigator.mediaDevices` – доступ к камере и микрофону.
`navigator.bluetooth`, navigator.usb – доступ к устройствам Bluetooth и USB.
</details>

<details>
<summary>Разница между методами Light dom и shadow dom?</summary>

Дополнить ....
</details>

<details>
<summary>Какие ещё способы назначить обработчик, кроме addEventListener?</summary>

- Через onclick когда инлайного мы пишем в HTML коде. 

- Либо пишем квериселектор, а потом вызываем onclick и вешаем его на кнопку
</details>


<h2 align="center">Другие вопросы</h2>


<details>
<summary>Что такое Solid и расшифруйте его?</summary>

- S `(single responsibility principle)` - принцип единственной ответственный. Функция, метод внутри класса должен выполнять лишь 1 задачу. Например - отсортировать массив или отфильтровать его 

- O `(open-closed principle)` - принцип открытости и закрытости. Код должен быть написан так, чтобы в него можно было добавлять новый функционал, но при этом исходный код не должен быть изменен. На классах мы можем это сделать через extends

- L `(liskov substitution principle)` - принцип подставки Барбары Лисков. Наследуемый класс должен уметь делать всё то же самое, что и родительский, не ломая логику программы.

- I `(interface segregation)` - принцип разделения интерфейса. Есть один большой интерфейс внутри которого разные методы относящиеся к разным темам, и в наследуемом классе не нужно все их использовать

- D `(dependency inversion)` - принцип инверсии зависимостей

---.

D => `Dependency inversion` (принцип инверсии зависимостей) => модули высокого уровня не должны зависеть от модулей более низкого уровня, все они должны зависеть от абстракций, а они в свою очередь не должны зависеть от деталей, а детали как раз должны зависеть от абстракции. 

У нас есть завод, внутри завода есть станки, работники, электричество = они между собой связаны, в свою очередь станки также могут иметь детали: скажем наручник №1, крутилка №007. Представим себе что одна из деталей сломалось, мы меняем эту деталь в станке и оказывается, что логика работы станка меняется. Наши работники с этим станком теперь работать не могут, или для другой детали нужна будет более мощное электричество и здесь как раз происходит принцип инверсии зависимостей. У нас модули высокого уровня зависят от модулей низкого уровня. Чтобы этого избежать - можно исп так называемый трансформатор (некая абстракция), который сам подберет напряжения

</details>

<details>
<summary>Что такое ООП?</summary>

Полиморфизм - способность функции работать с различными типами данных. Например есть функция, которые может принимать разные типы данных: string и number, но функция одна.

</details>