// Factory Method (фабричный метод)
/* Основная цель - создания класса, которая в свою очередь будет помогать нам создавать
определенные объекты на основании каких-нибудь входных данных. Исходный класс можно назвать
супер-классом */
/* Используем тогда когда нам необходимо создавать множество однотипных объектов, другими 
словами объекты однаковой структурой, но разными данными. Причем эти объекты могут содер-
жать как свойства, так и методы */

class Bmw {
    // собирает объект из свойств: модель, цена и максимальная скорость
	constructor(model, price, maxSpeed) {
		this.model = model;
		this.price = price;
		this.maxSpeed = maxSpeed;
	}
}

// Надстройка из фабрики, который оптимизирует весь процесс создания
/* Аргументы для конструктора (свойства нашего объекто - далее) передаются автоматически
а конструктор с определенными параметрами, вызывается в зависимости от аргумента, который
мы передаем в фабрику, таким образом с помощью созданной фабрики мы можем генерировать раз-
личные объекты и как вы видите - это генерация реализуется довольно просто. Мы создаем эк=
земпляр фабрики*/


class BmwFactory {
    // После чего вызываем метод create иь передаем нужный аргумент
	create(type) {
		if (type === 'X5')
			return new Bmw(type, 108000, 300);
		if (type === 'X6')
			return new Bmw(type, 111000, 320);
	}
}

const factory = new BmwFactory(); 

/* Самый распространненый кейс использовании фабрики - это сложность создания объектов
в конструкторе. Чаще всего когда он может создаватся из нескольких источников, а также 
данный Паттерн хорошо подходит когда нужно создавать несколько объектов с одинаковой струк-
турой, но разными данными */

const x5 = factory.create('X5')
console.log(x5);      // Object {maxSpeed: 300, model: "X5", price: 108000}

const x6 = factory.create('X6')
console.log(x6);      // Object {maxSpeed: 320, model: "X6", price: 111000}

/* Минус данного подхода заключаетс в том, что при создании большого кол-во объектов структура 
нашего фабричного метода начнет разрастаться*/