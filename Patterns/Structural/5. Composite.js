/* Паттерн компоновщик - структурный паттерн проектирования, которая позволяет скгруппировать множество
компонентов в древовидную структуру и работать с этой структурой так как буд-то это 1 единственный объект */

// Особенности:
/* 1. Структура
Ключевая структура данного паттерна - это дерево (объект со специфическим интерфейсом). Особенность данного
интерфейса в том, что сам объект мало что знает о вложенных в него структурах. Он просто реализует те же методы, что
и вложенные в него компоненты, но вместо непосредственного вызова своего метода он передает вызовы всем вложенным
компонентом, а те компоненты в свою очередь передают эти вызовы в собственные вложенные структуры => Один исходный класс
содержит компоненты, которые в свою очередь также содержат компоненты - это и есть древовидная структура.
Все вложенные компоненты можно называть листями, связи между ними - ветками */

/* 2. Интерфейс. Еще одна особенность данного паттерна - это единный интерфейс вызова 
В самом корневом компоненте никаких действий не происходит, вызовы он передает или делегирует во все
вложенные компоненты по цепочке и методы вызываются непосредственно в каждом из них */

/* Например: автомобиль состоит из различный запчастей, самая крупная - кузов и внутренности двигателя. 
В свою очередь кузов состоит из каркаса, слоя, шпаклевки, краски, лаки и т.д. Внутренности двигателя - 
непосредственно самого двигателя, аккумулятора, радиаторы, электрики, но а сам же двигатель состоит из 
корпуса, целлиндра, прокладок и т. д. => Древовидная структура. То есть мы разбираем целовый автомобиль
на составные части */

/* Теперь представим, что нам необходимо посчитать себе стоимость автомобиля прежде чем его продавать =>
Нам нужно взять все составные части, взять цену и выдать одну цифру*/

/*Базовый интерфейс для наших запчастей, у нас есть таблица excel, которая содержит имя и цену и нам
необходимо трансформировать это в рабочий вид.*/
// Данный класс поможет нам создавать объекты с единым интерфейсом (иметь одинаоквые точки тоступа) взаимодействия - один из критерия паттерна
class Equipment {
	// Получение стоимости и имени
	getPrice() { return this.price || 0; }
	getName() { return this.name; }

	// Установка имени и цены
	setName(name) { this.name = name; }
	setPrice(price) { this.price = price; }
}

// Двигатель
class Engine extends Equipment {
	constructor() {
		super();
		this.setName('Engine');
		this.setPrice(800);
	}
}
// Кузов
class Body extends Equipment {
	constructor() {
		super();
		this.setName('Body');
		this.setPrice(3000);
	}
}
// Гайки, болты и т.д. => tools
class Tools extends Equipment {
	constructor() {
		super();
		this.setName('Tools');
		this.setPrice(4000);
	}
}

// Класс компонофщик, который просчитывает общую стоимость оборудования. 
class Composite extends Equipment {
	constructor() {
		super();
		this.equipments = [];
	}
	// Добавляем обородование в наш автомобиль
	add(equipment) {
		this.equipments.push(equipment);
	}
	/* Берет массив добавленного обородование, пробегается по нему и вызывает метод
	getprice у каждого. В результате чего у нас появляется массив цен. После чего нам 
	нужно с помощью reduce просумировать все значения*/
	getPrice() {
		return this.equipments
			.map(equipment => equipment.getPrice())
			.reduce((a, b) => a + b);
	}
}
// Тестируем работу 
class Car extends Composite {
	constructor() {
		super();
		this.setName('Audi');
	}
}
// Создаем экземпляр данного автомобиля
const myCar = new Car();

// Комплектуем его всем необходимым.
myCar.add(new Engine());
myCar.add(new Body());
myCar.add(new Tools())

// После чего проверяем итоговую стоимость получившего авто
console.log(`${myCar.getName()} price is ${myCar.getPrice()}$`);    // Audi price is 7800$