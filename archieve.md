1. Какие ты знаешь виды тестов?

`Unit-test` - это когда мы проверяем какой-то кусочек кода отдельно от всего приложения. Например при сложении двух чисел или написать тест, которая проверяет на наличие пробелов, проверить на наличие какого-то айтема в списке.

Библиотеки: Jest, Vitest

`Integration-tests` - интеграционные тесты - проверить как несколько частей программы работают вместе. Например: 
- Форма логина - когда человек пишет имя, а потом пароль, а потом нажимает отправить. И приходит ответ вы вошли
- Пример магазин - человек добавляет в корзину товар, там счетчик увеличивается, потом сумма пересчитывается и обновляется страница

`E2E (End-to-End tests)` - проверяет как работает все приложение от начало до конца, как будто им пользуется настоящий человек. Прям каждый пункт мы описываем

Библиотека Cypress

3. Какие есть методы у vitest / jest?

`describe('')` - когда мы хотим тесты объединить в один общий блок. Ну и внутри написать `test('')` и что мы тестируем. Мы например можем скипнуть какой-то определенный тест через метод
`.skip`, с помощью метода `.todo` - мы можем выделить какой тест еще предстоит нам писать

Всякие beforeAll, afterAll - выполняются перед или после завершение всех тестово. Например когда у нас есть фейковый сервер, то мы один раз к нему можем обратится. 

Есть также методы всякие через expect() 
.toBe() - проверяет на строгое равенство,
.toBeTruthy, toBeFalse - проверяет является ли значение истинные или ложным
.toBeNull(), toBeUndefined() - проверка на undefined
.resolves.toBe() - проверка успешного промиса

--- 

`Замыкание`

Замыкание - функции со своим лексическое окружение. И когда за пределами функции есть переменная, которого внутри нашего лексического окружения нет, то он дает доступ обращаться к этой переменной.

`This - контекст`

This — это контекст, который является динамическим. В зависимости от того, где мы его вызываем, на то он и будет ссылаться. Например, если мы вызовем его глобально, то ссылка будет указывать на объект window (в браузере). Если же вызов будет внутри метода объекта, то this будет ссылаться на сам объект. Если внутри обычной функции — то также на глобальный объект window. Однако у стрелочных функций нет собственного this, и они заимствуют его из внешнего контекста, в котором были определены.

`Прототип` - это основной объект родитель

`Прототипное наследование`

Прототипное наследование — это механизм, при котором один объект может использовать свойства и методы другого объекта, унаследовав их через прототип, а точнее proto.

`Разница между proto и prototype?`
- proto используется в объектах, а prototype в функций

`Как работает цепочка прототипов (prototype chain)?`

Когда мы обращаемся к св-в внутри объекта, то он в начале ищет
его внутри самого объекта, если не находит, то ищет внутри прото (прототип), а потом внутри него, если у нас есть цепочка прототипов.

Если нигде в цепочке свойство не найдено — возвращается undefined.

асинхронщина.

Ртк и ртк-query.

посмотри инструменты отладки, как точку остановы ставить, как ее ставить условно

Инструменты отладки:
- console.log();
- через инструмент разработчика Chrome() - когда мы пишем в коде debugger (некая точка останова) и проверяем в хроме передаются ли значение в дочерний компонент. Либо можем просто внутри браузера ставить эти точки остановы под цифрами. Есть также нетворк где можно узнать какие запросы литеть и правильно ли мы передали какой-либо запрос
- React Developer Tools и postman