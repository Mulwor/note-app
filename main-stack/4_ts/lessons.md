Существует несколько видов типизации:

`Статическая типизация` - типы проверяются на этапе компиляции, а не выполнения.

`Явная типизация` - это когда мы указываем явно тип. Например: `let variable: number = 5`

`Выводимая типизация` - ts по значению сам определит и сам тип выведет. Например:  `let variable = 5`. При этом тип number зафиксируется и туда строку уже не получится запихнуть

`Структурная типизация`  - когда у нас объявлены два типа и они отличаются только название типов. Например: 

| Первый тип | Второй тип  | 
|------------|-------------|
| type User = {        | type Person = { |
|   firstname: string; |  firstname: string; |
|   lastname: string;  |  lastname: string; |
| }                    | } |

С точки зрения TS - эти типы взаимозаменяемые (то есть если какая-то функция на тип ожидает person), а вы передадите туда тип user, то TS будет все равно он схавает этот тип.

---

Типы в ТС можно поделить на разные группы:
- Примитивы: string, number, bigInt, boolean, undefined, null, symbol;
- Специальные типы: any, unknown, never, void;
- Составные типы (Composite type) - объекты, массивы и т.д.
- Литералы: 'red' | 'green'
- Дженерики (generic types)
- Union / intersection (означает что итоговый тип включает только то что есть в типе Х и то что есть в типе Y. То есть обязательно должно присутствовать все поля в типе). 

Подтип (subtype) должен включать все поля, которые есть у надтипа (родителя) и плюс может добавлять свои. Надтип (super type) - содержит меньше свойств или методов, чем подтип. 

## Подробнее про специальный тип

| Специальный тип | Его значение | SuperType (надтип) | Subtype (подтип) |
|------------|---------|---------|---------|
| any  | отключает полностью любую проверку типов. Когда пишем any можем использовать все что угодно от любых примитивов до объектов | Присутствует | Присутствует |
| unknown | безопасный аналог any, когда мы не знаем какой тип нам ожидается на вход. Сделать его неизвестным и засчет соответствующих проверок безопасно его обработать. П.С. если мы действительно не знаем с каким типом нам предстоит работать, то необходимо использовать unknown | Присутствует  | Нет  |
| never    | пустое множество или недостижимое значение. Если какая-то функция или какое-то выражение не может вернуть значение или не завершается нормально, так как пробрасывает ошибку, то такая функция всегда возвращает never | Нет  | Присутствует |
| void    | это тип, функция, которой ничего не возвращает. | -  | -  |

## Преобразование типов

Преобразование типов подразумевает когда мы один тип - явно или не явно превращаем в другой. И для этого есть два метода, через as (плохая практика) и через satisfies (хорошая практика).

- В продакшене AS нельзя использовать, так как это any только в другой обертке. Однако его можно использовать в конфигах, тестах, при работе с html элементом (иногда), в утилитарных функциях когда мы пишем какие-то хелперы с работы с определенным кодом, когда тс не может вывести тип.