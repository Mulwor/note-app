### Worker Threads

Модуль `worker_threads` позволяет выполнять JavaScript-код в параллельных потоках **в рамках одного процесса**, не блокируя основной поток Event Loop. Стоит отметить, что  **worker threads** не разделяют состояние приложения. Каждый воркер имеет свою изолированную копию данных,

**Основное назначение:** выполнение ресурсоемкии **CPU-интенсивных** операций (математические вычисления, обработка данных, работа с изображениями). Для простых I/O операций (чтение файлов, сетевые запросы) использование воркеров нецелесообразно - достаточно асинхронных операций.

**Ключевые преимущества:**
- Потоки работают в одном процессе (меньше накладных расходов)
- Возможность разделения памяти через `SharedArrayBuffer`
- Быстрый запуск по сравнению с созданием отдельного процесса
- Идеально подходит для параллелизации CPU-нагрузки

**Например базовый пример вычисления корня 10 млн.раз:**

**main.js:**
```javascript
const { Worker } = require('worker_threads');

const worker = new Worker('./worker.js', {
  // Передаем начальные данные: {start: 1, end: 10000000} при старте
  workerData: { start: 1, end: 10000000 }
});

worker.on('message', (result) => console.log(`Результат: ${result}`));
worker.on('error', (err) => console.error('Ошибка в воркере:', err));
worker.on('exit', (code) => {
  if (code !== 0) console.error(`Воркер завершился с кодом: ${code}`);
});
```

**worker.js:**
```javascript
// Получаем доступ к API для общения с основным потоком
const { parentPort, workerData } = require('worker_threads');

function heavyCalculation(start, end) {
  let sum = 0;
  for (let i = start; i <= end; i++) {
    // Вычисляем квадратный корень 10 миллионов раз!
    sum += Math.sqrt(i);
  }
  return sum;
}

const result = heavyCalculation(workerData.start, workerData.end);
parentPort.postMessage(result);
```

Стоит отметить, что **worker.on('')** принимает несколько событий: `online` оповещает нас, что worker запустился и выполнил начальную загрузку, `message` - получает сообщение от worker, `error` произошла ошибка в worker, `exit` - worker завершил работу. 

Помимо события `.on` у `worker-threads` есть также свои методы и свойства. 

| Метод | Что делает данный метод | 
| ----- | ----------------------- |
| `.postMessage(value)` | Отправляет данные |
| `.terminate()`   | Асинхронно завершает работу воркера (возвращает Promise). | 
| `.ref()` - режим по умолчанию / `.unref()` | Это методы, которые контролируют должен ли Node.js ждать завершения этого воркера перед тем, как завершить работу всей программы. Когда ты создаешь воркер, Node.js по умолчанию считает его активной задачей, которую нужно дождаться. Программа не завершится, пока жив хотя бы один воркер. |
| `threadId` | Уникальный id worker |
| `.stdin, .stdout, .stderr` |	(Потоки) Доступ к стандартным потокам ввода/вывода воркера, если они были разрешены при его создании. |

Вот другие примеры использование worker threads:
1. [Вычисление суммы чисел в отдельном потоке](./worker/first/main.js)
2. [Двустороннее общение](./worker/third/main.js)
3. [Параллельная обработка массива данных](./worker/second/main.js)
4. [Пример с ref](./worker/ref/main.js)
