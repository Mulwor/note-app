# Самообучающийся материал по Node.js

## Оглавление

- [Введение](#введение)
- [Зачем нужен Node.js](#зачем-нужен-nodejs)
- [Ключевые особенности Node.js](#ключевые-особенности-nodejs)
- [Модули в Node.js](#модули-в-nodejs)
  - [Основные преимущества использования модулей](#основные-преимущества-использования-модулей)
  - [Какие модули бывают](#какие-модули-бывают)
    - [IIFE](#IIFE)
    - [CommonJS](#CommonJS)
    - [EcmaScript modules](#ESM)
  - [Модульная система](#module-system)
    - [process](#module-system-process)
    - [events (событийный механизм)](#module-system-events)
    - [file system (работа с файлами)](#module-system-file-system)
    - [streams (работа с потоками данных)](#module-system-streams)
    - [os (информация об ОС)](#module-system-os)
    - [http (создание сервера)](#module-system-http)
    - [timers & related](#module-system-timers-and-related)
- [Подробнее про streams (работу с потоками данных)]()
    - [Понятие стримов](#понятие-стримов);
    - [Преимущество стримов](#преимущество-стримов);
    - [Какие есть виды стримов](#виды-стримов);
    - [С какими видами данных работают стримы](#данные-стримов);
    - [Подробнее про виды стримов](#подробнее-про-виды-и-данные-стримов);
      - [Writable stream](#writable-stream);
          - [Writable api event emitter](#writable-api-event);
          - [Writable полезные свойства](#writable-полезные-свойства);
      - [Readable stream](#readable-stream);
          - [Readable mode](#readable-mode);
          - [Readable api event emitter](#readable-api-event);

---

<a id="введение"></a>
## Введение

Node.js - среда выполнения js-кода на сервере. У него есть особая среда, например когда вы можете писать js-код, который будет взаимодействовать с файловой системой, с операционной системой благодаря которой мы можем, использовать js-код не только в браузере.

<a id="зачем-нужен-nodejs"></a>
## Зачем нужен Node.js

1. Когда мы хотим построить input, output - интенсивное приложение. Это означает, что есть задачи, которые не имеют так много вычислений, но при этом очень много данных идет на вход и много нужно отдавать на выход. Например - API (что-то отдают на фронт, получают с него запросы, делают несложные действия - например достать что-то из базы, что-то туда записать и отдать на фронт результат);

2. Когда мы хотим отдавать какие-то данные по частям (data streaming applications) - например мы можем отдавать видео, какие-то другие данные в потоке;

3. CLI (Command line interface) applications - это интерфейс командной строки. Если нам не нужен UI, и какая-то красивая графика и мы хотим чтобы наше приложение выполняло какие-то действия;

4. IoT (Internet of things) - устройство для умного дома, которое контролирует освещение, для контроля температуры в доме, включения лампочек и т.д. А в node-js он используется для применения в микроконтроллерах;

5. Cloud - если мы захотим использовать такие cloud провайдеры как Amazon Web Services или google cloud platform и microsoft azure, то с помощью него (node.js) мы можем писать лямбды функции, и мы можем писать приложения, которые там будем разворачивать;

<a id="ключевые-особенности-nodejs"></a>
## Какие есть ключевые особенность у Node.js

1. **Среда выполнения JavaScript**. Node.js позволяет выполнять JavaScript-код вне браузера, на сервере.

2. **Движок V8**. Node.js использует движок V8 от Google, который применяет JIT-компиляцию (Just-In-Time). Это позволяет очень быстро компилировать и выполнять код.

3. **Однопоточная модель с Event Loop**. В отличие от сред, где под каждый запрос создается отдельный поток (что потребляет много памяти и ресурсов), Node.js использует однопоточную модель. В её основе лежит Event Loop (цикл событий), который обрабатывает события и асинхронные операции. Крайне важно не блокировать его выполнением тяжелых синхронных операций.

4. **Кроссплатформенность**. Node.js позволяет писать код, который будет работать на разных операционных системах (Windows, Linux, macOS) и устройствах (компьютеры, серверы, иногда даже микроконтроллеры).

5. **Событийно-ориентированная архитектура (Event-Driven Architecture)**. Node.js построен на событиях, что идеально подходит для обработки множества одновременных операций ввода-вывода (например, запросов к базе данных, сетевых вызовов).

6. **Высокая масштабируемость (Scalability)**. Благодаря своей архитектуре Node.js очень хорошо масштабируется. Можно легко создавать новые экземпляры приложения с помощью дочерних процессов (child processes), выделять тяжелые задачи в отдельные потоки (worker threads) и масштабировать приложение с помощью кластеризации (cluster).

7. **Богатый встроенный API**. Node.js обладает обширной стандартной библиотекой, содержащей множество встроенных модулей (для работы с файловой системой, сетью, HTTP и т.д.). Это предоставляет готовый функционал для решения основных задач.

<a id="модули-в-nodejs"></a>
## Модули в Node.js

Node.js считает любой файл - модулем и существует несколько способов как писать эти модули.

Модули - это такой способ организации кода когда отдельный какой-то функционал помещается в отдельный файл и соответственно содержимое этого файла оно экспортируется / импортируется в другие файлы (модули).

<a id="основные-преимущества-использования-модулей"></a>
### Основные преимущества использования модулей

1. Кодовая база делится на различные файлы, что упрощает понимание каждого куска кода;

2. Облегчается переиспользование кода - если модуль написан правильно, то есть он в себя принимает какие-то входные данные, он что-то с ними делает и отдает какие-то выходные данные;

3. Изоляция кода и его сокрытия - мы знаем, что модуль требует для своей работы, что отдает и внутри он что-то делает, но если это хорошо написанный модуль, то по сути не важно как реализованно именно его внутренний код. И удобно нам как скрывать эту функциональность и изолировать;

4. Модули позволяют нам лучше управлять зависимостями;

<a id="какие-модули-бывают"></a>
### Какие модули бывают

<a id="IIFE"></a>
#### 1. IIFE с примером кода

```js
const IIFE_module = (() => {
  let innerVariable = 'Secret value!';

  const publicInterface = {
    getValue() {
      return innerVariable;
    },
    setValue(newValue) {
      if (typeof newValue === 'string') {
        innerVariable = newValue;
      } else {
        innerVariable = "DEFAULT"
      }
    }
  }

  return publicInterface
})();

console.log(IIFE_module.getValue())

IIFE_module.setValue('new str')
console.log(IIFE_module.getValue())

IIFE_module.setValue(12334)
console.log(IIFE_module.getValue())
```

---

<a id="CommonJS"></a>
#### 2. CommonJS

CommonJS, где импорт осуществляется через `require(moduleName)`, а экспорт - через `exports` или `module.exports`.

**Разница между `exports` и `module.exports`:**
- И `exports`, и `module.exports` изначально ссылаются на один и тот же пустой объект
- `exports` - это просто переменная-ссылка на `module.exports`
- При присваивании `exports = 'string'` мы перезаписываем эту ссылку, теряя связь с `module.exports`, поэтому модуль вернет пустой объект
- При использовании `exports.a = 'string'` мы модифицируем общий объект, поэтому свойства доступны
- `module.exports` можно безопасно перезаписывать полностью

**Работа `require()`:**
Синхронная функция `require(moduleName)` ищет модули в порядке:
1. Встроенные модули Node.js (fs, path и т.д.)
2. По относительным/абсолютным путям (`./`, `../`, `/`)
3. В папке `node_modules` текущей директории и родительских директорий

**Кеширование:** Модуль загружается только один раз при первом вызове `require()`, затем результат кешируется.

<a id="ESM"></a>
#### 3. ESM (EcmaScript modules)

Выделяют следующие способы установки модуля:

a. Можно ко всем файлам вместо js установить .mjs и у нас будет использоваться import;

b. package.json написать type и выбрать "module" - так он будет понимать, что мы используем модули;

c. Через терминал написав node --input-type=module nameFile;

Есть несколько видов импортов:

- `import default from "module-name";` - дефолтный экспорт
- `import * as name from 'module-name'` - возьмется все импорты и запишется в переменную name
- `import { name_01, name_02 as Loge } from 'module-name'` - импорт с деструктиризацией и запись в переменную Loge
- `import defaultExport, { export [, [...] ] } from module-name`
- `import module-name` по типу `require('./')`;
- Динамические импорты: `import("/module-name.js").then(module => {...}).catch(error => {})`

Есть несколько видов экспорта:
- Классический экспорт `const a = 2
export { a }` и экспорт переменной через `export const a = 2`;
- Переименовка экспорта `export { a as name, b }; import { name } from 'name-file';`
- Экспорт по дефолту - когда нам необходимо экспортировать определенную функцию - `const a = 1` или просто `export default a`.
- Можно экспортировать одно по умолчанию, а другие нет - `export { a as default, b, c}`

Как работают импорты, они имеют 3 фазы:
- Construction (parsing) - в ней ищутся все импорты модулей и рекурсивно загружается контент со всех модулей
- Instantiation - для каждой сущности сохраняется именованная ссылка в памяти, но в ней пока не привязываются какие-то значения. Они помогают взаимоотношения между импортами
- Evaluation - фаза выполнения. На этой фазе node берет и выполняет код всех этих сущностей инстанцированных используя вот эти связи и после этого у нас возможен запуск кода в загружаемом модуле. Потому что все вычисления были выполнены.

Ключевые особенности:
- Native JS modules (через import)
- Импорт асинхронный
- Импорты не работают в блоках кода
- this будет undefined
- Есть import.meta
- Нет default __dirname, __filename, require, exports, module. Но заменить можно след.образом dirname:

```js
import { fileURLToPath } from 'url';
import { dirname } from 'path'; 

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename)
```

Аналог require:

```js
import {createRequire} from 'module'

const require = createRequire(import.meta.url);
```

- Ecmascript modules такие же как в браузере

---

<a id="module-system"></a>
### Модульная система

---

Node.js использует модульную систему. То есть вся встроенная функциональность разбита на отдельные пакеты или модули. Модуль представляет блок кода, который может использоваться повторно в других модулях. А так модули делятся на 3 типа: 

1\. `Packages (3-rd party)` - внешние модули, которые мы устанавливаем;

2\. `Core modules (built-in)` - это модули которые установлены по умолчанию внутри node-js, например мы импортируем их - fs, streams и.т.д.; 

3\. `Модули собственно кода` - когда мы пишем приложение на node.js мы реализуем функционал в виде какого-то кода и этот код разделяется по файлам, соответственно и эти файлы будут являться модулями

Вот некоторые примеры методов модулей:

<a id="module-system-process"></a>

Process - предоставляет полные данные о системе, параметрах запуска, переменных окружении и потребялемых процессом ресурсах. Он глобальный и импортировать его не стоит

1. `process.pid` - получить id текущего процесса в котором запускается node-js;
2. `process.argv` - получаем аргументы командной строки с которым было запущено  приложение;
3. `process.report.writeReport()` - получаем отсчет нашего процесса - о том сколько он употребляет памяти, в каком окружении он работает;
4. `process.on("SIGTERM", () => {...})` - можем подписываться на системные сигналы;
5. `process.exit()` - можем завершить текущий процесс;

<a id="module-system-events"></a>

Events - позволяет реализовывать API, подписки на события и их эмита. EventEmitter() - это такая сущность, которая позволяет подписываться на события и их емитить. 

```js
const EventEmitter = require('events');
const calculator = new EventEmitter();
calculator.on('sum', (a, b) => console.log(`Result is ${a + b}`))
calculator.emit('sum', 1, 3 )
```

<a id="module-system-file-system"></a>

File system (файловая система) - представляет собой абстракцию в node-js файловых систем вашей хостовой машины и позволяет вам выполнять различные полезные операции. Например получения информации о файла 

```js
const fs = require('fs/promises');
const fileStats = await fs.stat('photos/cute/funny-cat.jpg');

console.log(fileStats.isFile())    // ? Проверка на является ли файл - файлом?
console.log(fileStats.size)        // ? Размер файла в битах
console.log(fileStats.birthname)   // ? Дата создания файла
```

<a id="module-system-streams"></a>

Streams - когда мы используем некий интерфейс для того, чтобы работать с данными по частям - не читать сразу весь файл, а разделить его на части. Например когда мы хотим прочитать данные из request-body, записывать данные, duplex работают как для чтения так и для записи

```js
const {Readable} = require('stream');

class MyAwesomeReadStream extends Readable {
  constructor(options) {
    super(options)
    // Initialization
  }

  _read(n) {
    // Reading Logic
  }
}
```

Посмотреть лекцию => https://www.youtube.com/watch?v=o1WPOQgPT3Y

<a id="module-system-os"></a>

Os - информация об операционной системе и об аппаратном обеспечении компьютера, на котором работает Node.js, только в виде чтения

```js
const os = require('os');

console.log(os.cpus())                  // ? Получаем список нашим процессов
console.log(os.networkInterfaces())     // ? Получаем все network интерфейсы, которые привязаны к текущему адресу
console.log(os.freemem())               // ? Кол-во свободной памяти в системе;
```

<a id="module-system-http"></a>

Для сетевых запросов мы используем http - модуль который позволяет обрабатывать (как получать так и отправлять) запросы, то есть мы можем создать http сервис, 

```
const http = require('http');
const server  = http.createServer((request, response) => {
  request.end("Hello from Node.js!")
})
server.listen(4000)
```

<a id="module-system-timers-and-related"></a>

Timers & related (отложенное исполнения коллбеков)
1. setTimeout(() => {...}, 500)
2. setInterval(() => {...}, 500)
3. setImmediate(() => {...}, 500) - выполняется всегда после пол.фазы евентлупа, которые забирает новые инпут и отпут события с коллбеками. 
4. process.nextTick(() => {...}, 500) - попадают специальные приоритетные очереди, они выполняются быстрее всего
5. queueMictotask(() => {...}, 500) - она попадает в очередь микротасок, туда же попадают и промисы, которые будут выполняться за nextTick внутри приоритетных очередей

Прочитать - https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick


---


<a id="понятие-стримов"></a>
`Stream` - абстрактный интерфейс для работы с потоковыми данными. Это унифицированный программный интерфейс для чтения или записи данных, сокетов и переносов данных между процессами. 

<a id="преимущество-стримов"></a>
У стримов есть следующие преимущество:

1\. Принцип разделения ответственности. Он создает маленькие компоненты, которые делают что-то одно, но они делают это очень хорошо. Таким образом мы можем менять код изолированного чего-то одного, что позволяет лучше управлять нашим приложением

2\. Гибкость, их можно легко подключать подключать, перенаправлять (когда направляем какие-то данные из одного источника в несколько мест назначения)

3\. Эффективность по времени и памяти, так как они получают данные по кусочкам, они потребляет небольшое кол-в памяти и это потребления памяти является фиксированным потому что поток который через stream он равномерен.

---

<a id="подробнее-про-виды-и-данные-стримов"></a>

### Виды и данные стримов

В node.js 4 основных видах стрима: writable (нужен для писания данных), readable (нужен для чтения данных), duplex (могут как читать так и писать), transform (вычислять на основе входных данных - выходные данные и отдавать их дальше). Стримы работают с двумя видами данных - это буфферы (или строки) и объекты. 

Буфферы - абстрактный способом хранения последовательности данных фиксированной длины. Буфферы - такие объекты, которые нужны для представления данных фиксированной длины. Это также подкласс unitInArray. Способы создания буфферов. В начале нам необходимо импортировать буфер `const { Buffer } = require('buffer')`;

| Код | Описание |
|-----|----------|
| `const emptyBuffer = Buffer.alloc(42);` | Если передаем 1 аргумент, то создается пустой буфер, который имеет размер 42 байта |
| `const filledBuffer = Buffer.alloc(42, 1);` | Если передаем 2 аргумента, то создается буфер, который имеет размер 42 байта содержащих единицу |
| `const fasterCreatedBuffer = Buffer.allocUnsafe(42, 1);` | Еще 1 способ создания буфера. Он небезопасный, работает быстрее, но может захватить больше области памяти в которых уже имеются какие-то данные и прежде чем с ним работать нужно эти данные отчистить |
| `const bufferFromStringDefaultUTF8 = Buffer.from('javascript');` | Буфер может быть создан из строки |
| `const bufferFromStringLatin1 = Buffer.from('javascript', 'latin1');` | Также вторым аргументом можем передавать кодировку |
| `const bufferFromArray = Buffer.from([1,2,3]);` | Буфер также можно создавать из массива |

[Пример кода](./streams/01-buffer.js), а также подробнее можно почитать в [документации](https://nodejs.org/api/buffer.html)

Буферы также считаются итерируемыми объектами - то есть с помощью цикла for of мы можем перебрать их. Все стримы используют какие-то внутренние буфферы для хранения каких-то данных. Кол-в данных определяется размером буффера. Чтобы узнать порог ("ограничение по памяти") можно использовать хай watermark. 

---

<a id="writable-stream"></a>

### Writable streams

Writable streams наследники базового класса одного-именного writable, которые находится в модуле стримы. И они предоставляют два метода с которыми можно работать - метод `WRITABLE.WRITE` и `WRITABLE.END`. 

Какие есть стримы во writable: 

1\. `request` - запрос на клиентской стороне;

2\. `response` - ответ на серверной стороне;

3\. `process.stdout` и `process.stderr` - потоки для вывода данных';

5\. `child process stdin`;

6\. `fs-streams`;

7\. `zlib` - модуль для архивации (сжатие данных);

8\. `crypto` - всевозможные шифрования;

9\. `TCP sockets` и т.д;

<a id="writable-api-event"></a>

Все стримы, включая writable использует API eventemitter (встроенный модуль в node.js, который предоставляет функционал нам для работы с событиями), позволяет нам эмитеть некие события, генерировать, подписаться и т.д. Основной список событий, который эмитит у нас writable stream: 

1\. `error` - события эмитится когда происходит какая-то ошибка и для обработки ошибки мы можем подписать на это события;

2\. `drain` - когда внутренний буфер заполняется, то с помощью данного метода когда буфер освободится он сразу же запишет какие-то значения;

3\. `close` - когда стрим ресурс закрывается или завершается и он не может писать данные - метод writable.destroy;

4\. `finish` - когда процесс записи завершается и все данные уже записаны пример writable.end();

5\. `pipe` - когда readable стрим пайпится в writable stream;

6\. `unpipe` - когда readable стрим отсоединяется от writable stream;

<details>
<summary>Пример кода</summary>

```js
const fs = require('fs');

// Читает из /01-buffer.js и записывает в другой файл
const rs = fs.createReadStream('./01-buffer.js');
const ws = fs.createWriteStream('new_file.txt');

// Подписываемся на все события
ws.on('close', () => console.log("Writable stream has been closed"));
ws.on('finish', () => console.log("Writable streams has been finished"));
ws.on('pipe', () => console.log("Piped to readable stream"));
ws.on('unpipe', () => console.log("Unpiped from readable stream"));

/*
  Вот что выведется в console.log
  
  В начале отработал события подсоединение к стриму => 
    1. Piped to readable stream, 
  затем у нас стрим завершился обработал события close =>
    2. Writable streams has been finished
  затем у нас обработался finish, потому что запись завершилась =>
    3. Unpipe from readable stream
  а в конце уже обработался close => 
    4. Writable stream has been closed
*/

ws.on('error', (err) => console.log(`Error occurred: ${err}`));
ws.destroy(new Error("Ooops"))

rs.pipe(ws);
```
</details>

<a id="writable-полезные-свойства"></a>

### Полезные свойства

Помимо событий у него есть еще методы и какие-то полезные свойства: 

1\. `WRITABLE.WRITE`, принимает 3 параметра - 1. то что надо записать, 2. callback, 3. кодировка (по умолчанию UTF-8, если ничего не передать). <details>
<summary>Пример кода</summary>

```js
const buf = Buffer.from("Buffer")

process.stdout.write("LALALALA");
process.stdout.write("\n");
process.stdout.write(buf);
process.stdout.write('\n');

{/*
  Вот что выведется в console.log:
    В начале вывелось LALALALA, 
    затем сработал перенос строки "\n",
    затем вывелся буффер в виде строки 
    и снова перевод строки
*/}

// Например мы можем записать еще один кусочек в этом коллбеке
process.stdout.write("Write with callback", () => { 
  process.stdout.write("\nCallback!")
});`
```
</details>

Он возвращает true/false. Если false то у нас переполнился внутренний буффер и мы должны что-то с этим сделать прежде чем писать. Например куда-то отдать эти данные
<br />

2\. `WRITABLE.END` - метод когда мы хотим записать какой-то последний кусочек данных, и после этого стрим у нас будет закрыт 

<details>
<summary>Пример кода</summary>

```js
const { createWriteStream } = require('fs');

const writable = createWriteStream('./output.txt');
writable.write("First-line\n");
writable.write("Second-line\n");
writable.write("Third-line\n");

writable.end("Finished");

// Если после завершение, мы напишем метод write, то у нас будет ошибка
writable.write("One more plus")
```
</details>

<br />


3\. `WRITABLE.DESTROY` - делает грубое закрытие стрима (ломает). В качестве аргумента он может принимать ошибку и если мы его передали, то эту ошибку можно обработать через error

<details>
<summary>Пример кода</summary>

```js
const { createWriteStream } = require('fs');

const writable = createWriteStream('./output.txt');

writable.write("First-line\n");
writable.write("Second-line\n");

// Можем передать ошибку сюда
writable.destroy();

// Если после завершение, мы напишем метод write, то у нас будет ошибка
writable.write("One more plus")
writable.end("Finished")
```

</details>

<br />

4\. `WRITABLE.CORK` & `WRITABLE.UNCORK` (используется редко). Метод `.CORK` - он заставляет все записанные данные буфферизоваться в памятиб он никуда никакие данные не запишет пока не будет вызван метод `.uncork`. Они работают в паре 

<details>
<summary>Пример кода</summary>

```js
const { createWriteStream } = require('fs');
const writable = createWriteStream('./output.txt');

writable.cork();

writable.write("1-line\n");
writable.write("2-line\n");
writable.write("3-line\n");
writable.write("4-line\n");
writable.write("5-line\n");
writable.write("6-line\n");

writable.uncork();
```
</details>

Стоит отметить, у нас кол-во `cork()` должно совпадать с `uncork()`, то есть если у одного два, то и другого должно быть столько

Полезно использовать тогда когда chunks быстро записываются и мы не хотим их сразу быстро отправлять, мы в начале их буферизуем и нам не нужно дожидатся выполнения чанков и мы отдадим сразу все на выходе с помощью метод uncork();
 
Другие методы:
| Метод | Описание |
|-----|----------|
| writable.setDefaultEncoding(encoding) | Установить дефолтную кодировку для строк с которыми он будет работать |
| writable.destroyed | Показывает (true/false) был ли вызван метод ,destroy | 
| writable.writable | Показывает можно ли еще стрим использовать для того, чтобы писать |
| writable.writableEnded | Показывает был ли вызван метод .end |
| writable.writableCorked | Показывает был ли вызван метод .cork и при этом не вызван ли метод .uncork |
| writable.writableHighWaterMark | Можем получить значения HighWaterMark для этого стрима | 
| writable.writableLength | Показывает число, байт или объектов готовые к записи |
| writable.writableNeedDrain | Флаг, который показывает нужно ли чистить наш внутренний буфер |
| writable.writableObjectMode | Геттер для object-мода, если у нас true, то стрим у нас работает в object-mode если нет, то работает со строками

---

<a id="readable-stream"></a>

### Readable streams 

Readable streams нужны нам для чтения данных. Какие есть readable stream: 

1\. `request(server side)` на серверной стороне, так как мы их читаем, 

2\. `response(client side)` так читаем ответ сервера, 

3\. `process.stdin()` - стандартный поток ввода

4\. `child process stdout`, `stderr` - те потоки, которые мы можем читать из дочернего процесса. 

5\. `fs streams`

6\. `zlib`, `crypto`, `TCP sockets` и так далее. 


<a id="readable-mode"></a>

### Readable stream modes

У readable stream есть несколько modes (режимы чтения):

1\. `Paused mode` - когда он находится в остановленном состоянии. Он не читает данные, чтобы их буфферизировать, чтобы их прочитать нам надо явно вызвать метод readable. Когда мы только создаем стрим fs.createStream - он не читает данные, он находится в paused mode, надо явно указать чтобы он начал читать 

2\. `Flowing mode` - когда он находится в текущем состоянии (в состоянии потока). Когда readable stream читает данные автоматически и отдает их дальше так быстро как это возможно и метод внутренний readable.read он вызывается автоматом

Для того, чтобы переключить с paused mode на flowing mode можно:

1\. Повесить обработчик события на data

2\. Вызвать метод readable.resume (продолжить чтения)

3\. Использовать readable.pipe(writable)

А для того чтобы перевести его обратно в pause mode  

1\. Мы должны вызвать readable.pause метод, который его остановит, однако это не сработает если readable куда-то запайпили. 
2\. Если у него есть какие-то пайпы, то необходимо отключить все через readable.unpipe.

Что нужно понимать - Readable стрим не отдает данные никуда до тех пор пока не реализовали механизм, который их поглощать. 

<a id="readable-api-event"></a>

### Readable api event emitter

Он тоже использует API event-emitter и имеет список событий

1\. `.data` - подписавший на событие мы можем читать данные

<details>
<summary>Пример кода</summary>

```js
const { createServer } = require("http");
const PORT = 3000;

// Представим себе, что мы с клиента отправляем запрос, который содержит тело и нам
// это тело нужно прочитать и что-то с ним сделать
const server = createServer((request, response) => {
  let body = ""; 

  // Подписываемся на событие date, и здесь у нас callback, 
  // который передается чанк с данными и приводим к строке
  request.on('data', (chunk) => {
    body += chunk.toString();
  });

  // После чего мы просто отправляем на клиент сообщение, что тело
  // было успешно прочитано и мы отправляем сколько в нем было св-в
  request.on('end', () => {
    const parsedBody = JSON.parse(body);
    console.log('Parsed body', parsedBody);

    const propsCount = Object.keys(parsedBody).length;
    console.log("Props count", propsCount);

    response
      .writeHead(200, { "Content-type": "text/plain" })
      .end(`Body from request has been successfully accepted and parsed. It has ${propsCount}`)
  })
})

server.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`)
})
```
</details>

<br />

2\. `.readable` - имитится тогда когда можно прочитать какие-то данные

<details>
<summary>Пример кода</summary>

```js
const { createServer } = require("http");
const PORT = 3000;

const server = createServer((request, response) => {
  let body = ""; 

  // Подписываемся на readable, когда вылетает данное событие когда стрим говорит нам, что нужно прочитать. У меня есть данные приди и забери
  request.on('readable', () => {
    let chunk;
    // req.read() - берем и вызываем метод read() - он возвращает нам либо наши данные либо null (возвращает в том случае когда достигнут конец нашего источника данных в нашем случае когда body будет прочитано до конца либо когда данные не готовы - когда мы забираем быстрее чем они помещаются в наш буфер)
    // Пока результат не является наллом мы записываем значения
    while ((chunk = req.read()) !== null) {
        body += chunk.toString();
    }
  });

  request.on('end', () => {/* Тоже самое что и в первом примере */})
})

server.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`)
})
```
</details>

Основное отличие при событии data у нас автоматически генерится эти события, stream перешел во `Flowing mode` и нам не надо вручную дергать метод `readable.read`. А события readable говорит вот сейчас подходящий момент чтобы вызвать метод read и вы уже сами его вызываете

3\. `.end` - эмитится когда у нас больше нет данных, которых можно прочитать. Данное события выйдет только тогда когда события будут полностью поглащены (то есть когда они будут отданы куда-то)

4\. `.pause` - эмитится когда вызывает метод readable.pause и при этом он не равно false. Когда будет фиктивный вызов

5\. `.resume` - эмитится когда вызывает метод readable.resume и при этом reable.flowing у нас не равен true

6\. `.error` - для обработки ошибок

7\. `.close` - когда стрим у нас закрывается

---

Источники:

[Rolling scopes school -  NodeJS 2021Q2 Modules](https://www.youtube.com/watch?v=RXFOAqsWzFA)