# Самообучающийся материал по Node.js

## Оглавление

- [Введение](#введение)
- [Зачем нужен Node.js](#зачем-нужен-nodejs)
- [Ключевые особенности Node.js](#ключевые-особенности-nodejs)
- [Модули в Node.js](#модули-в-nodejs)
  - [Основные преимущества использования модулей](#основные-преимущества-использования-модулей)
  - [Какие модули бывают](#какие-модули-бывают)
    - [IIFE](#IIFE)
    - [CommonJS](#CommonJS)
    - [EcmaScript modules](#ESM)
      - [Виды импортов и экспортов](#import-and-exports)
      - [Ключевые особенности](#key-features)
  - [Модульная система](#module-system)
      - [process](#module-system-process)
      - [events (событийный механизм)](#module-system-events)
      - [file system (работа с файлами)](#module-system-file-system)
      - [streams (работа с потоками данных)](#module-system-streams)
      - [os (информация об ОС)](#module-system-os)
      - [http (создание сервера)](#module-system-http)
      - [timers & related](#module-system-timers-and-related)
- [Подробнее про streams (работу с потоками данных)]()

---

<a id="введение"></a>
## Введение

Node.js - среда выполнения js-кода на сервере. У него есть особая среда, например когда вы можете писать js-код, который будет взаимодействовать с файловой системой, с операционной системой благодаря которой мы можем, использовать js-код не только в браузере.

<a id="зачем-нужен-nodejs"></a>
## Зачем нужен Node.js

1. Когда мы хотим построить input, output - интенсивное приложение. Это означает, что есть задачи, которые не имеют так много вычислений, но при этом очень много данных идет на вход и много нужно отдавать на выход. Например - API (что-то отдают на фронт, получают с него запросы, делают несложные действия - например достать что-то из базы, что-то туда записать и отдать на фронт результат);

2. Когда мы хотим отдавать какие-то данные по частям (data streaming applications) - например мы можем отдавать видео, какие-то другие данные в потоке;

3. CLI (Command line interface) applications - это интерфейс командной строки. Если нам не нужен UI, и какая-то красивая графика и мы хотим чтобы наше приложение выполняло какие-то действия;

4. IoT (Internet of things) - устройство для умного дома, которое контролирует освещение, для контроля температуры в доме, включения лампочек и т.д. А в node-js он используется для применения в микроконтроллерах;

5. Cloud - если мы захотим использовать такие cloud провайдеры как Amazon Web Services или google cloud platform и microsoft azure, то с помощью него (node.js) мы можем писать лямбды функции, и мы можем писать приложения, которые там будем разворачивать;

<a id="ключевые-особенности-nodejs"></a>
## Какие есть ключевые особенность у Node.js

1. **Среда выполнения JavaScript**. Node.js позволяет выполнять JavaScript-код вне браузера, на сервере.

2. **Движок V8**. Node.js использует движок V8 от Google, который применяет JIT-компиляцию (Just-In-Time). Это позволяет очень быстро компилировать и выполнять код.

3. **Однопоточная модель с Event Loop**. В отличие от сред, где под каждый запрос создается отдельный поток (что потребляет много памяти и ресурсов), Node.js использует однопоточную модель. В её основе лежит Event Loop (цикл событий), который обрабатывает события и асинхронные операции. Крайне важно не блокировать его выполнением тяжелых синхронных операций.

4. **Кроссплатформенность**. Node.js позволяет писать код, который будет работать на разных операционных системах (Windows, Linux, macOS) и устройствах (компьютеры, серверы, иногда даже микроконтроллеры).

5. **Событийно-ориентированная архитектура (Event-Driven Architecture)**. Node.js построен на событиях, что идеально подходит для обработки множества одновременных операций ввода-вывода (например, запросов к базе данных, сетевых вызовов).

6. **Высокая масштабируемость (Scalability)**. Благодаря своей архитектуре Node.js очень хорошо масштабируется. Можно легко создавать новые экземпляры приложения с помощью дочерних процессов (child processes), выделять тяжелые задачи в отдельные потоки (worker threads) и масштабировать приложение с помощью кластеризации (cluster).

7. **Богатый встроенный API**. Node.js обладает обширной стандартной библиотекой, содержащей множество встроенных модулей (для работы с файловой системой, сетью, HTTP и т.д.). Это предоставляет готовый функционал для решения основных задач.

<a id="модули-в-nodejs"></a>
## Модули в Node.js

Node.js считает любой файл - модулем и существует несколько способов как писать эти модули.

Модули - это такой способ организации кода когда отдельный какой-то функционал помещается в отдельный файл и соответственно содержимое этого файла оно экспортируется / импортируется в другие файлы (модули).

<a id="основные-преимущества-использования-модулей"></a>
### Основные преимущества использования модулей

1. Кодовая база делится на различные файлы, что упрощает понимание каждого куска кода;

2. Облегчается переиспользование кода - если модуль написан правильно, то есть он в себя принимает какие-то входные данные, он что-то с ними делает и отдает какие-то выходные данные;

3. Изоляция кода и его сокрытия - мы знаем, что модуль требует для своей работы, что отдает и внутри он что-то делает, но если это хорошо написанный модуль, то по сути не важно как реализованно именно его внутренний код. И удобно нам как скрывать эту функциональность и изолировать;

4. Модули позволяют нам лучше управлять зависимостями;

<a id="какие-модули-бывают"></a>
### Какие модули бывают

<a id="IIFE"></a>
#### 1. IIFE с примером кода

```js
const IIFE_module = (() => {
  let innerVariable = 'Secret value!';

  const publicInterface = {
    getValue() {
      return innerVariable;
    },
    setValue(newValue) {
      if (typeof newValue === 'string') {
        innerVariable = newValue;
      } else {
        innerVariable = "DEFAULT"
      }
    }
  }

  return publicInterface
})();

console.log(IIFE_module.getValue())

IIFE_module.setValue('new str')
console.log(IIFE_module.getValue())

IIFE_module.setValue(12334)
console.log(IIFE_module.getValue())
```

---

<a id="CommonJS"></a>
#### 2. CommonJS

CommonJS, где импорт осуществляется через `require(moduleName)`, а экспорт - через `exports` или `module.exports`.

**Разница между `exports` и `module.exports`:**
- И `exports`, и `module.exports` изначально ссылаются на один и тот же пустой объект
- `exports` - это просто переменная-ссылка на `module.exports`
- При присваивании `exports = 'string'` мы перезаписываем эту ссылку, теряя связь с `module.exports`, поэтому модуль вернет пустой объект
- При использовании `exports.a = 'string'` мы модифицируем общий объект, поэтому свойства доступны
- `module.exports` можно безопасно перезаписывать полностью

**Работа `require()`:**
Синхронная функция `require(moduleName)` ищет модули в порядке:
1. Встроенные модули Node.js (fs, path и т.д.)
2. По относительным/абсолютным путям (`./`, `../`, `/`)
3. В папке `node_modules` текущей директории и родительских директорий

**Кеширование:** Модуль загружается только один раз при первом вызове `require()`, затем результат кешируется.

<a id="ESM"></a>
#### 3. ESM (EcmaScript modules)

Выделяют следующие способы установки модуля:

a. Можно ко всем файлам вместо js установить .mjs и у нас будет использоваться import;

b. package.json написать type и выбрать "module" - так он будет понимать, что мы используем модули;

c. Через терминал написав node --input-type=module nameFile;

<a id="import-and-exports"></a>

Есть несколько видов импортов:

- `import default from "module-name";` - дефолтный экспорт
- `import * as name from 'module-name'` - возьмется все импорты и запишется в переменную name
- `import { name_01, name_02 as Loge } from 'module-name'` - импорт с деструктиризацией и запись в переменную Loge
- `import defaultExport, { export [, [...] ] } from module-name`
- `import module-name` по типу `require('./')`;
- Динамические импорты: `import("/module-name.js").then(module => {...}).catch(error => {})`

Есть несколько видов экспорта:
- Классический экспорт `const a = 2
export { a }` и экспорт переменной через `export const a = 2`;
- Переименовка экспорта `export { a as name, b }; import { name } from 'name-file';`
- Экспорт по дефолту - когда нам необходимо экспортировать определенную функцию - `const a = 1` или просто `export default a`.
- Можно экспортировать одно по умолчанию, а другие нет - `export { a as default, b, c}`

Как работают импорты, они имеют 3 фазы:
- Construction (parsing) - в ней ищутся все импорты модулей и рекурсивно загружается контент со всех модулей
- Instantiation - для каждой сущности сохраняется именованная ссылка в памяти, но в ней пока не привязываются какие-то значения. Они помогают взаимоотношения между импортами
- Evaluation - фаза выполнения. На этой фазе node берет и выполняет код всех этих сущностей инстанцированных используя вот эти связи и после этого у нас возможен запуск кода в загружаемом модуле. Потому что все вычисления были выполнены.

<a id="key-features"></a>
Ключевые особенности:
- Native JS modules (через import)
- Импорт асинхронный
- Импорты не работают в блоках кода
- this будет undefined
- Есть import.meta
- Нет default __dirname, __filename, require, exports, module. Но заменить можно след.образом dirname:

```js
import { fileURLToPath } from 'url';
import { dirname } from 'path'; 

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename)
```

Аналог require:

```js
import {createRequire} from 'module'

const require = createRequire(import.meta.url);
```

- Ecmascript modules такие же как в браузере

---

<a id="module-system"></a>
### Модульная система

---

Node.js использует модульную систему. То есть вся встроенная функциональность разбита на отдельные пакеты или модули. Модуль представляет блок кода, который может использоваться повторно в других модулях. А так модули делятся на 3 типа: 

1\. `Packages (3-rd party)` - внешние модули, которые мы устанавливаем;

2\. `Core modules (built-in)` - это модули которые установлены по умолчанию внутри node-js, например мы импортируем их - fs, streams и.т.д.; 

3\. `Модули собственно кода` - когда мы пишем приложение на node.js мы реализуем функционал в виде какого-то кода и этот код разделяется по файлам, соответственно и эти файлы будут являться модулями

Вот некоторые примеры методов модулей:

<a id="module-system-process"></a>

Process - предоставляет полные данные о системе, параметрах запуска, переменных окружении и потребялемых процессом ресурсах. Он глобальный и импортировать его не стоит

1. `process.pid` - получить id текущего процесса в котором запускается node-js;
2. `process.argv` - получаем аргументы командной строки с которым было запущено  приложение;
3. `process.report.writeReport()` - получаем отсчет нашего процесса - о том сколько он употребляет памяти, в каком окружении он работает;
4. `process.on("SIGTERM", () => {...})` - можем подписываться на системные сигналы;
5. `process.exit()` - можем завершить текущий процесс;

<a id="module-system-events"></a>

Events - позволяет реализовывать API, подписки на события и их эмита. EventEmitter() - это такая сущность, которая позволяет подписываться на события и их емитить. 

```js
const EventEmitter = require('events');
const calculator = new EventEmitter();
calculator.on('sum', (a, b) => console.log(`Result is ${a + b}`))
calculator.emit('sum', 1, 3 )
```

<a id="module-system-file-system"></a>

File system (файловая система) - представляет собой абстракцию в node-js файловых систем вашей хостовой машины и позволяет вам выполнять различные полезные операции. Например получения информации о файла 

```js
const fs = require('fs/promises');
const fileStats = await fs.stat('photos/cute/funny-cat.jpg');

console.log(fileStats.isFile())    // ? Проверка на является ли файл - файлом?
console.log(fileStats.size)        // ? Размер файла в битах
console.log(fileStats.birthname)   // ? Дата создания файла
```

<a id="module-system-streams"></a>

Streams - когда мы используем некий интерфейс для того, чтобы работать с данными по частям - не читать сразу весь файл, а разделить его на части. Например когда мы хотим прочитать данные из request-body, записывать данные, duplex работают как для чтения так и для записи

```js
const {Readable} = require('stream');

class MyAwesomeReadStream extends Readable {
  constructor(options) {
    super(options)
    // Initialization
  }

  _read(n) {
    // Reading Logic
  }
}
```

Посмотреть лекцию => https://www.youtube.com/watch?v=o1WPOQgPT3Y

<a id="module-system-os"></a>

Os - информация об операционной системе и об аппаратном обеспечении компьютера, на котором работает Node.js, только в виде чтения

```js
const os = require('os');

console.log(os.cpus())                  // ? Получаем список нашим процессов
console.log(os.networkInterfaces())     // ? Получаем все network интерфейсы, которые привязаны к текущему адресу
console.log(os.freemem())               // ? Кол-во свободной памяти в системе;
```

<a id="module-system-http"></a>

Для сетевых запросов мы используем http - модуль который позволяет обрабатывать (как получать так и отправлять) запросы, то есть мы можем создать http сервис, 

```
const http = require('http');
const server  = http.createServer((request, response) => {
  request.end("Hello from Node.js!")
})
server.listen(4000)
```

<a id="module-system-timers-and-related"></a>

Timers & related (отложенное исполнения коллбеков)
1. setTimeout(() => {...}, 500)
2. setInterval(() => {...}, 500)
3. setImmediate(() => {...}, 500) - выполняется всегда после пол.фазы евентлупа, которые забирает новые инпут и отпут события с коллбеками. 
4. process.nextTick(() => {...}, 500) - попадают специальные приоритетные очереди, они выполняются быстрее всего
5. queueMictotask(() => {...}, 500) - она попадает в очередь микротасок, туда же попадают и промисы, которые будут выполняться за nextTick внутри приоритетных очередей

Прочитать - https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick


---

Источники:

[Rolling scopes school -  NodeJS 2021Q2 Modules](https://www.youtube.com/watch?v=RXFOAqsWzFA)