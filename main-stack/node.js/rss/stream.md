Stream - абстрактный интерфейс для работы с потоковыми данными. Это унифицированный программный интерфейс для чтения или записи данных, сокетов и переносов данных между процессами. 

<a id="преимущество-стримов"></a>
Преимущество streams:

- Принцип разделения ответственности. Он создает маленькие компоненты, которые делают что-то одно, но они делают это очень хорошо. Таким образом мы можем менять код изолированного чего-то одного, что позволяет лучше управлять нашим приложением
- Гибкость, их можно легко подключать подключать, перенаправлять (когда направляем какие-то данные из одного источника в несколько мест назначения)
- Эффективность по времени и памяти, так как они получают данные по кусочкам, они потребляет небольшое кол-в памяти и это потребления памяти является фиксированным потому что поток который через stream он равномерен.

<a id="виды-и-данные-стримов"></a>
В node.js 4 основных видах стрима: writable (нужен для писания данных), readable (нужен для чтения данных), duplex (могут как читать так и писать), transform (вычислять на основе входных данных - выходные данные и отдавать их дальше).  

Стримы работают с двумя видами данных - это буфферы (или строки) и объекты. 
Буфферы - абстрактный способом хранения последовательности данных фиксированной длины. 

Буфферы - такие объекты, которые нужны для представления данных фиксированной длины. Это также подкласс unitInArray. Способы создания буфферов

`const { Buffer } = require('buffer')`;

| Код | Описание |
|-----|----------|
| `const { Buffer } = require('buffer');` | В начале импортируем его
| `const emptyBuffer = Buffer.alloc(42);` | Если передаем 1 аргумент, то создается пустой буфер, который имеет размер 42 байта |
| `const filledBuffer = Buffer.alloc(42, 1);` | Если передаем 2 аргумента, то создается буфер, который имеет размер 42 байта содержащих единицу |
| `const fasterCreatedBuffer = Buffer.allocUnsafe(42, 1);` | Еще 1 способ создания буфера. Он небезопасный, работает быстрее, но может захватить больше области памяти в которых уже имеются какие-то данные и прежде чем с ним работать нужно эти данные отчистить |
| `const bufferFromStringDefaultUTF8 = Buffer.from('javascript');` | Буфер может быть создан из строки |
| `const bufferFromStringLatin1 = Buffer.from('javascript', 'latin1');` | Также вторым аргументом можем передавать кодировку |
| `const bufferFromArray = Buffer.from([1,2,3]);` | Буфер также можно создавать из массива |

Буферы также считаются итерируемыми объектами - то есть с помощью цикла for of мы можем перебрать их. И стоит отметить, что все стримы используют какие-то внутренние буфферы для хранения каких-то данных. Кол-в данных определяется размером буффера. Чтобы узнать порог можно использовать хай вотер марк. 

<a href="./streams/01-buffer.js">

<details>
<summary>Writable streams</summary>
Writable streams наследники базового класса одного-именного writable, которые находится в модуле стримы. И они предоставляют два метода с которыми можно работать - метод write и end. 

Какие есть стримы во writable: request(client side) - запрос на клиентской стороне, response - ответ на серверной стороне, process.stdout и process.stderr, child process stdin, fs-streams, zlib, crypto, TCP sockets, etc. 

Все стримы включается writable использует API eventemitter (встроенный модуль в node.js), который предоставляет функционал нам для работы с событиями, позволяет нам emit некоторые события, подписаться и т.д. Основной список: 
- error;
- drain (когда внутренний буфер заполняется, то с помощью данного метода когда буфер освободится он сразу же запишет какие-то значения);
- close (когда стрим закрывается или завершается - метод destroy);
- finish - когда процесс записи завершается и все данные уже записаны пример writable.end();- pipe (когда readable стрим pipe в writable stream);
- unpipe (когда readable стрим отсоединяется от writable stream);

[Пример кода](./streams/02-writable-events.js)

Помимо событий у него есть еще методы и какие-то полезные свойства: `write`, который принимает 3 параметра - то что надо записать, callback, кодировка (по умолчанию UTF-8, если ничего не передать), `end` - метод когда мы хотим записать какой-то последний кусочек данных, после него не пишем write метод, так как [иначе выбросит ошибку](./streams/03-writable-end.js), `.destroy` - завершает стрим грубо, `.cork` - он заставляет все записанные данные буфферизоваться в памяти пока не будет вызван метод `.uncork` - [работают они в паре](./streams/03-writable-end.js) - это полезно тогда когда чанки быстро записываются и мы не хотим их сразу быстро отправлять, мы в начале их буферизуем а дальше отправляем
 
1. `process.stdout.write("LALALALA");`
2. `process.stdout.write("\n");`
3. `const buf = Buffer.from("BUFFER"); process.stdout.write(buf);`
4. `process.stdout.write('\n');`
5. `process.stdout.write("Write with callback", () => { process.stdout.write("\nCallback!") });`
</details>

<details>
<summary>Readable streams</summary>

Стримы которые нужны нам для чтения данных. Какие есть readable stream: request(server side) на сервере, так как мы их читаем, соответственно на клиенте response так читаем ответ сервера, process.stdin(), child process stdout, stderr, fs streams, zlib, crypto, TCP sockets, etc. 

У readable stream есть несколько modes:
1. Paused mode - когда он находится в остановленном состоянии. Он не читает данные, чтобы их буфферизировать, чтобы явно их прочитать нам надо явно вызвать метод readable. Когда мы только создаем стрим fs.createStream - он не читает данные, он находится в paused mode, надо явно указать чтобы он начал читать 
2. Flowing mode - когда он находится в текущем состоянии. Когда readable stream читает данные автоматически и отдает их дальше так быстро как это возможно и метод внутренний readable.read он вызывается автоматом

Как и было сказано в начале он находится в paused mode и мы можем его переключить в flowing mode через: 
1. Повесить обработчик события на data
2. Вызвать метод readable.resume (продолжить чтения)
3. Использовать readable.pipe(writable)

А для того чтобы перевести его обратно в pause mode - мы должны вызвать readable.pause метод, который его остановит, однако это не сработает если readable куда-то запайпили. Если у него есть какие-то пайпы, то необходимо отключить все через unpipe например

Он тоже использует API event-emitter и имеет список событий
1. data - подписавший на событие мы можем читать данные
2. readable - имитится тогда когда можно прочитать какие-то данные, так же при конце стрима имитится данное событие
</details>