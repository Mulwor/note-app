# Абстрактные классы и интерфейсы

![132](https://user-images.githubusercontent.com/91879193/171996460-ff4cbcaa-e92c-48c4-80e6-1f86e28a1a3f.PNG)
В интерфейсах описаны методы, какие параметры принимают, какого типа, что возвращают эти методы, но при этом нет реализации. Также из интерфейса нельзя сделать объект

---

Абстрактные классы похожи на интерфейсы, в них также можно объявлять абстрактные методы, которые будут аналогом методов в интерфейсе (другими словами не будет реализации), но при этом в абстрактных классах можно создавать и обычные методы с какой-то реализации, с какой-то логикой. И класс, который будет наследоваться от абстрактного, унаследует от себя все обычные методы и также должен будет реализовывать методы абстрактные, то есть в них должна быть какая-то логика

Рассмотрим более подробно Интерфейсы:

| Код                                          |     Комментарий      |
| -------------------------------------------- | :------------------: |
| interface Reader { read(url); }              | Интерфейс для чтения |
| interface Writer { write(data); }            | Интерфейс для записи |
| class FileClient implements Reader, Writer { |          \*          |
| Read(url) { // Логика ) }                    |                      |
| Write(data) { // Логика ) }                  |                      |
| }                                            |                      |

- Класс, который имплементирует как чтения так и запись. Под имплементацией мы подразумеваем, что
  Класс должен реализовывать все методы, которые есть в интерфейсе, то есть в этом классе должен быть как метод рид, так и врайт и при этом должна быть реализация. Имплементировать мы можем неограниченое кол-во интерфейсов

---

Интерфейсы позволяют писать более гибкий код, достигать более гибкого полиморфизма и в целом в первую очередь систему необходимо проектировать на уровне интерфейса

| Код                                           |                                          Комментарий                                           |
| --------------------------------------------- | :--------------------------------------------------------------------------------------------: |
| class User { username: string; age: number; } |                        2. Создаем класс, который будет работать с User                         |
| interface Repository {                        |                          Создаем интерфейс, а затем объявим 4 метода                           |
| class FileClient implements Reader, Writer {  | 3. Делаем обобщение, тип Т – это нечто общее, что что-то приходит извне, то есть мы сами можем |
| create: (obj: T) => T;                        |                         определять какой тип там будет использоваться                          |
| get: () => T;                                 |                                                                                                |
| delete: (obj: T) => T;                        |                                                                                                |

В class UserRepo загорится красным, предупреждая, что этих методов нет, необходимо их добавить внутрь класса:
| Код | Комментарий |
| ------------------------ |:------------------:|
| class UserRepo implements Repository<User>{ | //1. Создаем класс, который предназначен для создания, получение, удаление и обновление пользователя |
| create: (obj: User): User { return undefined; } | |
| delete: (obj: User): User { return undefined; } | Делаем имплементацию методов |
| get: (): User { return undefined; } | |
| update: (obj: User): User { return undefined; } | |
| } | |

Суть данного примера заключается в том, что мы на этапе проектирования создаем некоторый интерфейс в котором определяем какие должны быть методы, а потом подстраиваясь под этот интерфейс мы реализуем классы
