Существует несколько видов типизации:

`Статическая типизация` - типы проверяются на этапе компиляции, а не выполнения.

`Явная типизация` - это когда мы указываем явно тип. Например: `let variable: number = 5`

`Выводимая типизация` - ts по значению сам определит и сам тип выведет. Например:  `let variable = 5`. При этом тип number зафиксируется и туда строку уже не получится запихнуть

`Структурная типизация`  - когда у нас объявлены два типа и они отличаются только название типов. Например: 

| Первый тип | Второй тип  | 
|------------|-------------|
| type User = {        | type Person = { |
|   firstname: string; |  firstname: string; |
|   lastname: string;  |  lastname: string; |
| }                    | } |

С точки зрения TS - эти типы взаимозаменяемые (то есть если какая-то функция на тип ожидает person), а вы передадите туда тип user, то TS будет все равно он схавает этот тип.

---

Типы в ТС можно поделить на разные группы:
- Примитивы: string, number, bigInt, boolean, undefined, null, symbol;
- Специальные типы: any, unknown, never, void;
- Составные типы (Composite type) - объекты, массивы и т.д.
- Литералы: 'red' | 'green'
- Дженерики (generic types)
- Union / intersection (означает что итоговый тип включает только то что есть в типе Х и то что есть в типе Y. То есть обязательно должно присутствовать все поля в типе). 

Подтип (subtype) должен включать все поля, которые есть у надтипа (родителя) и плюс может добавлять свои. Надтип (super type) - содержит меньше свойств или методов, чем подтип. 

## Подробнее про специальный тип

| Специальный тип | Его значение | SuperType (надтип) | Subtype (подтип) |
|------------|---------|---------|---------|
| any  | отключает полностью любую проверку типов. Когда пишем any можем использовать все что угодно от любых примитивов до объектов | Присутствует | Присутствует |
| unknown | безопасный аналог any, когда мы не знаем какой тип нам ожидается на вход. Сделать его неизвестным и засчет соответствующих проверок безопасно его обработать. П.С. если мы действительно не знаем с каким типом нам предстоит работать, то необходимо использовать unknown | Присутствует  | Нет  |
| never    | пустое множество или недостижимое значение. Если какая-то функция или какое-то выражение не может вернуть значение или не завершается нормально, так как пробрасывает ошибку, то такая функция всегда возвращает never | Нет  | Присутствует |
| void    | это тип, функция, которой ничего не возвращает. | -  | -  |

## Подробнее про литералы

Литералы - это какие-то конкретные значение, которые мы используем как тип. И нужно оно для того, чтобы сузить значение

Литералов существует несколько видов:
- Строковые литералы
- Числовые литералы
- Булевые литералы
- Шаблонные строковые литералы
- Составные литералы

## Подробнее про дженерики (generic types)

Generic нам нужны тогда когда мы не знаем четкий тип, который передаются в параметры.
С помощью дженериков мы говорим ТС определи сам тип переданного нам аргумента. Также 
мы можем указывать внутри дефолтные значение для дженериков

## Подробнее про сужение типов (narrowing types) 

Сужение типов (narrowing) - у нас есть два типа `number | string`, и в каком-то 
участке кода мы хотим их разъединить. И с числами работать как с числами, а со
строками работать как со строками. П.С. могут быть любые типы


## Подробнее про type-guard

Type Guards - любой механизм, который позволяет сузить пользовательские type guard, которые мы пишем самостоятельно в виде отдельных функций

## Преобразование типов

Преобразование типов подразумевает когда мы один тип - явно или не явно
превращаем в другой. И для этого есть два метода, через as (плохая практика)
и через satisfies (хорошая практика)

- В продакшене AS нельзя использовать, так как это any только в другой обертке. Однако его можно использовать в конфигах, тестах, при работе с
html элементом (иногда), в утилитарных функциях когда мы пишем какие-то хелперы с работы с определенным кодом, когда тс не может вывести тип

## Операторы typeof и keyof

Операторы typeof и keyof - есть typeof который используется как оператор js, оно происходит в рантайме, а в тс есть также свой оператор typeof который позволяет извлекать тип и потом перепроверять его. Если мы попытаемся изменить его то выведится ошибка если используем const. А keyof позволяет доставать ключи. Мы также можем keyof и typeof комбинировать - например у нас есть объект, мы делаем от него typeof и потом сразу же от этого типа берем keyof

`type PersonKey = keyof typeof obj`

## Операторы optional и non-null assertion

Optional - `?. (вопросительный знак с точкой)`. Когда мы хотим обратится к какому-то полю внутри объекта может быть так, что адреса у нас не будет и мы у undefined мы пытаемся получить какое-то поле и сразу же будет ошибка. Эту проблему можно решить с помощью вопросительного знака с точной

Non-null assertion - `!. (восклицательный знак с точкой)`- похож на any или ts-ignore - затычка чтобы просто убрать ошибку. Позволяет получить доступ к объекту, но убирает ошибку которая говорит тс. Не стоит использовать на проде, так как он небезопасный. Это можно использовать когда мы настраиваем вебпак конфиг, в тестах.

## Mapped types - это типы, которые позволяют создавать новые типы на основе существующих изменяя какие-то поля

## Asserts (2:14:40)